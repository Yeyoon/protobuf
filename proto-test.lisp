;;; This file automatically generated by protocol-compiler
;;; DO NOT EDIT!


(cl:in-package #:protocol-buffer)

(cl:defclass Test1Msg (protocol-buffer)
  (
    (foo
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'Test1Msg)


(cl:defun make-Test1Msg ()
  (cl:make-instance 'Test1Msg))
(cl:export 'make-Test1Msg)

(cl:defgeneric foo (proto))
(cl:defmethod foo ((self Test1Msg))
  (cl:slot-value self 'foo))

(cl:defgeneric (cl:setf foo) (new-value proto))
(cl:defmethod (cl:setf foo) (new-value (self Test1Msg))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'foo) new-value))

(cl:export 'foo)

(cl:defgeneric has-foo (proto))
(cl:defmethod has-foo ((self Test1Msg))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-foo)

(cl:defmethod cl:print-object ((object Test1Msg) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-foo object)
      (cl:format stream "foo: ~s " (foo object)))
  )
  (cl:values))

(cl:defgeneric clear-foo (proto))
(cl:defmethod clear-foo ((self Test1Msg))
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-foo)

(cl:defmethod clear ((self Test1Msg))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:values))

(cl:defmethod is-initialized ((self Test1Msg))
  cl:t)

(cl:defmethod octet-size ((self Test1Msg))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-foo self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (foo self))))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb Test1Msg) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:when (has-foo pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (foo pb))))
    )
  index)

(cl:defmethod merge ((self Test1Msg) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((8)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'foo) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test1Proto-TestGroup1 (protocol-buffer)
  (
    (a
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'Test1Proto-TestGroup1)


(cl:defun make-Test1Proto-TestGroup1 ()
  (cl:make-instance 'Test1Proto-TestGroup1))
(cl:export 'make-Test1Proto-TestGroup1)

(cl:defgeneric a (proto))
(cl:defmethod a ((self Test1Proto-TestGroup1))
  (cl:slot-value self 'a))

(cl:defgeneric (cl:setf a) (new-value proto))
(cl:defmethod (cl:setf a) (new-value (self Test1Proto-TestGroup1))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'a) new-value))

(cl:export 'a)

(cl:defgeneric has-a (proto))
(cl:defmethod has-a ((self Test1Proto-TestGroup1))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-a)

(cl:defmethod cl:print-object ((object Test1Proto-TestGroup1) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-a object)
      (cl:format stream "a: ~s " (a object)))
  )
  (cl:values))

(cl:defgeneric clear-a (proto))
(cl:defmethod clear-a ((self Test1Proto-TestGroup1))
  (cl:setf (cl:slot-value self 'a) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-a)

(cl:defmethod clear ((self Test1Proto-TestGroup1))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'a) 0)
  (cl:values))

(cl:defmethod is-initialized ((self Test1Proto-TestGroup1))
  cl:t)

(cl:defmethod octet-size ((self Test1Proto-TestGroup1))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-a self) (cl:incf size (cl:+ 2 (varint:length64 (base:int32-to-uint64 (a self))))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb Test1Proto-TestGroup1) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 171))
  (cl:when (has-a pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 176))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (a pb))))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 172))
  index)

(cl:defmethod merge ((self Test1Proto-TestGroup1) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((172)
           (cl:return-from merge index))
          ((176)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'a) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test1Proto-TestGroup2 (protocol-buffer)
  (
    (b
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'Test1Proto-TestGroup2)


(cl:defun make-Test1Proto-TestGroup2 ()
  (cl:make-instance 'Test1Proto-TestGroup2))
(cl:export 'make-Test1Proto-TestGroup2)

(cl:defgeneric b (proto))
(cl:defmethod b ((self Test1Proto-TestGroup2))
  (cl:slot-value self 'b))

(cl:defgeneric (cl:setf b) (new-value proto))
(cl:defmethod (cl:setf b) (new-value (self Test1Proto-TestGroup2))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'b) new-value))

(cl:export 'b)

(cl:defgeneric has-b (proto))
(cl:defmethod has-b ((self Test1Proto-TestGroup2))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-b)

(cl:defmethod cl:print-object ((object Test1Proto-TestGroup2) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-b object)
      (cl:format stream "b: ~s " (b object)))
  )
  (cl:values))

(cl:defgeneric clear-b (proto))
(cl:defmethod clear-b ((self Test1Proto-TestGroup2))
  (cl:setf (cl:slot-value self 'b) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-b)

(cl:defmethod clear ((self Test1Proto-TestGroup2))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'b) 0)
  (cl:values))

(cl:defmethod is-initialized ((self Test1Proto-TestGroup2))
  cl:t)

(cl:defmethod octet-size ((self Test1Proto-TestGroup2))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-b self) (cl:incf size (cl:+ 2 (varint:length64 (base:int32-to-uint64 (b self))))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb Test1Proto-TestGroup2) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 187))
  (cl:when (has-b pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 192))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (b pb))))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 188))
  index)

(cl:defmethod merge ((self Test1Proto-TestGroup2) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((188)
           (cl:return-from merge index))
          ((192)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'b) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defconstant +Test1Proto-FOO+ 0)
(cl:export '+Test1Proto-FOO+)
(cl:defconstant +Test1Proto-BAR+ 1)
(cl:export '+Test1Proto-BAR+)
(cl:defconstant +Test1Proto-BAZ+ 2)
(cl:export '+Test1Proto-BAZ+)

(cl:defclass Test1Proto (protocol-buffer)
  (
    (o_a
     :initform 0
     :type base:int64)

    (o_b
     :initform 0
     :type base:int64)

    (u_int32
     :initform 0
     :type base:int32)

    (u_int64
     :initform 0
     :type base:int64)

    (u_uint64
     :initform 0
     :type base:uint64)

    (u_fixed32
     :initform 0
     :type base:int32)

    (u_fixed64
     :initform 0
     :type base:int64)

    (u_bool
     :initform cl:nil
     :type cl:boolean)

    (u_float
     :initform 0f0
     :type cl:single-float)

    (u_double
     :initform 0d0
     :type cl:double-float)

    (u_string
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (u_vardata
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (u_msg
     :accessor u_msg
     :initform cl:nil
     :type (cl:or cl:null Test1Msg))

    (r_int32 :accessor r_int32
     :initform (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int32))

    (r_int64 :accessor r_int64
     :initform (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int64))

    (r_uint64 :accessor r_uint64
     :initform (cl:make-array 0 :element-type 'base:uint64 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:uint64))

    (r_fixed32 :accessor r_fixed32
     :initform (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int32))

    (r_fixed64 :accessor r_fixed64
     :initform (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int64))

    (r_bool :accessor r_bool
     :initform (cl:make-array 0 :element-type 'cl:boolean :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:boolean))

    (r_float :accessor r_float
     :initform (cl:make-array 0 :element-type 'cl:single-float :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:single-float))

    (r_double :accessor r_double
     :initform (cl:make-array 0 :element-type 'cl:double-float :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:double-float))

    (r_string :accessor r_string
     :initform (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:octet-vector))

    (r_vardata :accessor r_vardata
     :initform (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:octet-vector))

    (r_msg :accessor r_msg
     :initform (cl:make-array 0 :element-type 'Test1Msg :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector Test1Msg))

    (testgroup1 :accessor testgroup1
     :initform (cl:make-array 0 :element-type 'Test1Proto-TestGroup1 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector Test1Proto-TestGroup1))

    (testgroup2 :accessor testgroup2
     :initform (cl:make-array 0 :element-type 'Test1Proto-TestGroup2 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector Test1Proto-TestGroup2))

    (d_int32
     :initform 12
     :type base:int32)

    (d_string
     :initform (base:string-to-utf8-octets "foo")
     :type base:octet-vector)

    (d_bool
     :initform cl:t
     :type cl:boolean)

    (dd_int32
     :initform 12
     :type base:int32)

    (dd_string
     :initform (base:string-to-utf8-octets " f oo ")
     :type base:octet-vector)

    (dd_bool
     :initform cl:t
     :type cl:boolean)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 19))
  ))

(cl:export 'Test1Proto)


(cl:defun make-Test1Proto ()
  (cl:make-instance 'Test1Proto))
(cl:export 'make-Test1Proto)

(cl:defgeneric o_a (proto))
(cl:defmethod o_a ((self Test1Proto))
  (cl:slot-value self 'o_a))

(cl:defgeneric (cl:setf o_a) (new-value proto))
(cl:defmethod (cl:setf o_a) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'o_a) new-value))

(cl:export 'o_a)

(cl:defgeneric o_b (proto))
(cl:defmethod o_b ((self Test1Proto))
  (cl:slot-value self 'o_b))

(cl:defgeneric (cl:setf o_b) (new-value proto))
(cl:defmethod (cl:setf o_b) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'o_b) new-value))

(cl:export 'o_b)

(cl:defgeneric u_int32 (proto))
(cl:defmethod u_int32 ((self Test1Proto))
  (cl:slot-value self 'u_int32))

(cl:defgeneric (cl:setf u_int32) (new-value proto))
(cl:defmethod (cl:setf u_int32) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_int32) new-value))

(cl:export 'u_int32)

(cl:defgeneric u_int64 (proto))
(cl:defmethod u_int64 ((self Test1Proto))
  (cl:slot-value self 'u_int64))

(cl:defgeneric (cl:setf u_int64) (new-value proto))
(cl:defmethod (cl:setf u_int64) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_int64) new-value))

(cl:export 'u_int64)

(cl:defgeneric u_uint64 (proto))
(cl:defmethod u_uint64 ((self Test1Proto))
  (cl:slot-value self 'u_uint64))

(cl:defgeneric (cl:setf u_uint64) (new-value proto))
(cl:defmethod (cl:setf u_uint64) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_uint64) new-value))

(cl:export 'u_uint64)

(cl:defgeneric u_fixed32 (proto))
(cl:defmethod u_fixed32 ((self Test1Proto))
  (cl:slot-value self 'u_fixed32))

(cl:defgeneric (cl:setf u_fixed32) (new-value proto))
(cl:defmethod (cl:setf u_fixed32) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_fixed32) new-value))

(cl:export 'u_fixed32)

(cl:defgeneric u_fixed64 (proto))
(cl:defmethod u_fixed64 ((self Test1Proto))
  (cl:slot-value self 'u_fixed64))

(cl:defgeneric (cl:setf u_fixed64) (new-value proto))
(cl:defmethod (cl:setf u_fixed64) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_fixed64) new-value))

(cl:export 'u_fixed64)

(cl:defgeneric u_bool (proto))
(cl:defmethod u_bool ((self Test1Proto))
  (cl:slot-value self 'u_bool))

(cl:defgeneric (cl:setf u_bool) (new-value proto))
(cl:defmethod (cl:setf u_bool) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_bool) new-value))

(cl:export 'u_bool)

(cl:defgeneric u_float (proto))
(cl:defmethod u_float ((self Test1Proto))
  (cl:slot-value self 'u_float))

(cl:defgeneric (cl:setf u_float) (new-value proto))
(cl:defmethod (cl:setf u_float) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_float) new-value))

(cl:export 'u_float)

(cl:defgeneric u_double (proto))
(cl:defmethod u_double ((self Test1Proto))
  (cl:slot-value self 'u_double))

(cl:defgeneric (cl:setf u_double) (new-value proto))
(cl:defmethod (cl:setf u_double) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_double) new-value))

(cl:export 'u_double)

(cl:defgeneric u_string (proto))
(cl:defmethod u_string ((self Test1Proto))
  (base:utf8-octets-to-string (cl:slot-value self 'u_string)))
(cl:defgeneric u_string-octets (proto))
(cl:defmethod u_string-octets ((self Test1Proto))
  (cl:slot-value self 'u_string))
(cl:export 'u_string)

(cl:defgeneric (cl:setf u_string) (new-value proto))
(cl:defmethod (cl:setf u_string) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'u_string)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'u_string) new-value))))

(cl:export 'u_string)

(cl:defgeneric u_vardata (proto))
(cl:defmethod u_vardata ((self Test1Proto))
  (base:utf8-octets-to-string (cl:slot-value self 'u_vardata)))
(cl:defgeneric u_vardata-octets (proto))
(cl:defmethod u_vardata-octets ((self Test1Proto))
  (cl:slot-value self 'u_vardata))
(cl:export 'u_vardata)

(cl:defgeneric (cl:setf u_vardata) (new-value proto))
(cl:defmethod (cl:setf u_vardata) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'u_vardata)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'u_vardata) new-value))))

(cl:export 'u_vardata)

(cl:defgeneric u_msg (proto))
(cl:defmethod u_msg ((self Test1Proto))
  (cl:when (cl:null (cl:slot-value self 'u_msg))
    (cl:setf
      (cl:ldb (cl:byte 1 12)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'u_msg)
             (make-Test1Msg)))
  (cl:slot-value self 'u_msg))

(cl:defgeneric (cl:setf u_msg) (new-value proto))
(cl:defmethod (cl:setf u_msg) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'u_msg) new-value))

(cl:export 'u_msg)

(cl:export 'r_int32)

(cl:export 'r_int64)

(cl:export 'r_uint64)

(cl:export 'r_fixed32)

(cl:export 'r_fixed64)

(cl:export 'r_bool)

(cl:export 'r_float)

(cl:export 'r_double)

(cl:export 'r_string)

(cl:export 'r_vardata)

(cl:export 'r_msg)

(cl:export 'testgroup1)

(cl:export 'testgroup2)

(cl:defgeneric d_int32 (proto))
(cl:defmethod d_int32 ((self Test1Proto))
  (cl:slot-value self 'd_int32))

(cl:defgeneric (cl:setf d_int32) (new-value proto))
(cl:defmethod (cl:setf d_int32) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'd_int32) new-value))

(cl:export 'd_int32)

(cl:defgeneric d_string (proto))
(cl:defmethod d_string ((self Test1Proto))
  (base:utf8-octets-to-string (cl:slot-value self 'd_string)))
(cl:defgeneric d_string-octets (proto))
(cl:defmethod d_string-octets ((self Test1Proto))
  (cl:slot-value self 'd_string))
(cl:export 'd_string)

(cl:defgeneric (cl:setf d_string) (new-value proto))
(cl:defmethod (cl:setf d_string) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'd_string)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'd_string) new-value))))

(cl:export 'd_string)

(cl:defgeneric d_bool (proto))
(cl:defmethod d_bool ((self Test1Proto))
  (cl:slot-value self 'd_bool))

(cl:defgeneric (cl:setf d_bool) (new-value proto))
(cl:defmethod (cl:setf d_bool) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'd_bool) new-value))

(cl:export 'd_bool)

(cl:defgeneric dd_int32 (proto))
(cl:defmethod dd_int32 ((self Test1Proto))
  (cl:slot-value self 'dd_int32))

(cl:defgeneric (cl:setf dd_int32) (new-value proto))
(cl:defmethod (cl:setf dd_int32) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'dd_int32) new-value))

(cl:export 'dd_int32)

(cl:defgeneric dd_string (proto))
(cl:defmethod dd_string ((self Test1Proto))
  (base:utf8-octets-to-string (cl:slot-value self 'dd_string)))
(cl:defgeneric dd_string-octets (proto))
(cl:defmethod dd_string-octets ((self Test1Proto))
  (cl:slot-value self 'dd_string))
(cl:export 'dd_string)

(cl:defgeneric (cl:setf dd_string) (new-value proto))
(cl:defmethod (cl:setf dd_string) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 17) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'dd_string)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'dd_string) new-value))))

(cl:export 'dd_string)

(cl:defgeneric dd_bool (proto))
(cl:defmethod dd_bool ((self Test1Proto))
  (cl:slot-value self 'dd_bool))

(cl:defgeneric (cl:setf dd_bool) (new-value proto))
(cl:defmethod (cl:setf dd_bool) (new-value (self Test1Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 18) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'dd_bool) new-value))

(cl:export 'dd_bool)

(cl:defgeneric has-o_a (proto))
(cl:defmethod has-o_a ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-o_a)

(cl:defgeneric has-o_b (proto))
(cl:defmethod has-o_b ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-o_b)

(cl:defgeneric has-u_int32 (proto))
(cl:defmethod has-u_int32 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_int32)

(cl:defgeneric has-u_int64 (proto))
(cl:defmethod has-u_int64 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_int64)

(cl:defgeneric has-u_uint64 (proto))
(cl:defmethod has-u_uint64 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_uint64)

(cl:defgeneric has-u_fixed32 (proto))
(cl:defmethod has-u_fixed32 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_fixed32)

(cl:defgeneric has-u_fixed64 (proto))
(cl:defmethod has-u_fixed64 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_fixed64)

(cl:defgeneric has-u_bool (proto))
(cl:defmethod has-u_bool ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_bool)

(cl:defgeneric has-u_float (proto))
(cl:defmethod has-u_float ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_float)

(cl:defgeneric has-u_double (proto))
(cl:defmethod has-u_double ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_double)

(cl:defgeneric has-u_string (proto))
(cl:defmethod has-u_string ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_string)

(cl:defgeneric has-u_vardata (proto))
(cl:defmethod has-u_vardata ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_vardata)

(cl:defgeneric has-u_msg (proto))
(cl:defmethod has-u_msg ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-u_msg)

(cl:defgeneric has-d_int32 (proto))
(cl:defmethod has-d_int32 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-d_int32)

(cl:defgeneric has-d_string (proto))
(cl:defmethod has-d_string ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-d_string)

(cl:defgeneric has-d_bool (proto))
(cl:defmethod has-d_bool ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-d_bool)

(cl:defgeneric has-dd_int32 (proto))
(cl:defmethod has-dd_int32 ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-dd_int32)

(cl:defgeneric has-dd_string (proto))
(cl:defmethod has-dd_string ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 17) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-dd_string)

(cl:defgeneric has-dd_bool (proto))
(cl:defmethod has-dd_bool ((self Test1Proto))
  (cl:= (cl:ldb (cl:byte 1 18) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-dd_bool)

(cl:defmethod cl:print-object ((object Test1Proto) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-o_a object)
      (cl:format stream "o_a: ~s " (o_a object)))
    (cl:when (has-o_b object)
      (cl:format stream "o_b: ~s " (o_b object)))
    (cl:when (has-u_int32 object)
      (cl:format stream "u_int32: ~s " (u_int32 object)))
    (cl:when (has-u_int64 object)
      (cl:format stream "u_int64: ~s " (u_int64 object)))
    (cl:when (has-u_uint64 object)
      (cl:format stream "u_uint64: ~s " (u_uint64 object)))
    (cl:when (has-u_fixed32 object)
      (cl:format stream "u_fixed32: ~s " (u_fixed32 object)))
    (cl:when (has-u_fixed64 object)
      (cl:format stream "u_fixed64: ~s " (u_fixed64 object)))
    (cl:when (has-u_bool object)
      (cl:format stream "u_bool: ~s " (u_bool object)))
    (cl:when (has-u_float object)
      (cl:format stream "u_float: ~s " (u_float object)))
    (cl:when (has-u_double object)
      (cl:format stream "u_double: ~s " (u_double object)))
    (cl:when (has-u_string object)
      (cl:format stream "u_string: ~s " (u_string object)))
    (cl:when (has-u_vardata object)
      (cl:format stream "u_vardata: ~s " (u_vardata object)))
    (cl:when (has-u_msg object)
      (cl:format stream "u_msg: ~s " (u_msg object)))
    (cl:format stream "r_int32: ~s " (r_int32 object))
    (cl:format stream "r_int64: ~s " (r_int64 object))
    (cl:format stream "r_uint64: ~s " (r_uint64 object))
    (cl:format stream "r_fixed32: ~s " (r_fixed32 object))
    (cl:format stream "r_fixed64: ~s " (r_fixed64 object))
    (cl:format stream "r_bool: ~s " (r_bool object))
    (cl:format stream "r_float: ~s " (r_float object))
    (cl:format stream "r_double: ~s " (r_double object))
    (cl:format stream "r_string: ~s " (r_string object))
    (cl:format stream "r_vardata: ~s " (r_vardata object))
    (cl:format stream "r_msg: ~s " (r_msg object))
    (cl:format stream "testgroup1: ~s " (testgroup1 object))
    (cl:format stream "testgroup2: ~s " (testgroup2 object))
    (cl:when (has-d_int32 object)
      (cl:format stream "d_int32: ~s " (d_int32 object)))
    (cl:when (has-d_string object)
      (cl:format stream "d_string: ~s " (d_string object)))
    (cl:when (has-d_bool object)
      (cl:format stream "d_bool: ~s " (d_bool object)))
    (cl:when (has-dd_int32 object)
      (cl:format stream "dd_int32: ~s " (dd_int32 object)))
    (cl:when (has-dd_string object)
      (cl:format stream "dd_string: ~s " (dd_string object)))
    (cl:when (has-dd_bool object)
      (cl:format stream "dd_bool: ~s " (dd_bool object)))
  )
  (cl:values))

(cl:defgeneric clear-o_a (proto))
(cl:defmethod clear-o_a ((self Test1Proto))
  (cl:setf (cl:slot-value self 'o_a) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-o_a)

(cl:defgeneric clear-o_b (proto))
(cl:defmethod clear-o_b ((self Test1Proto))
  (cl:setf (cl:slot-value self 'o_b) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-o_b)

(cl:defgeneric clear-u_int32 (proto))
(cl:defmethod clear-u_int32 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_int32) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_int32)

(cl:defgeneric clear-u_int64 (proto))
(cl:defmethod clear-u_int64 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_int64) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_int64)

(cl:defgeneric clear-u_uint64 (proto))
(cl:defmethod clear-u_uint64 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_uint64) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_uint64)

(cl:defgeneric clear-u_fixed32 (proto))
(cl:defmethod clear-u_fixed32 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_fixed32) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_fixed32)

(cl:defgeneric clear-u_fixed64 (proto))
(cl:defmethod clear-u_fixed64 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_fixed64) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_fixed64)

(cl:defgeneric clear-u_bool (proto))
(cl:defmethod clear-u_bool ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_bool) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_bool)

(cl:defgeneric clear-u_float (proto))
(cl:defmethod clear-u_float ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_float) 0f0)
  (cl:setf
    (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_float)

(cl:defgeneric clear-u_double (proto))
(cl:defmethod clear-u_double ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_double) 0d0)
  (cl:setf
    (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_double)

(cl:defgeneric clear-u_string (proto))
(cl:defmethod clear-u_string ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_string) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_string)

(cl:defgeneric clear-u_vardata (proto))
(cl:defmethod clear-u_vardata ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_vardata) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_vardata)

(cl:defgeneric clear-u_msg (proto))
(cl:defmethod clear-u_msg ((self Test1Proto))
  (cl:setf (cl:slot-value self 'u_msg) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u_msg)

(cl:defgeneric clear-d_int32 (proto))
(cl:defmethod clear-d_int32 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'd_int32) 12)
  (cl:setf
    (cl:ldb (cl:byte 1 26) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d_int32)

(cl:defgeneric clear-d_string (proto))
(cl:defmethod clear-d_string ((self Test1Proto))
  (cl:setf (cl:slot-value self 'd_string) (base:string-to-utf8-octets "foo"))
  (cl:setf
    (cl:ldb (cl:byte 1 27) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d_string)

(cl:defgeneric clear-d_bool (proto))
(cl:defmethod clear-d_bool ((self Test1Proto))
  (cl:setf (cl:slot-value self 'd_bool) cl:t)
  (cl:setf
    (cl:ldb (cl:byte 1 28) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d_bool)

(cl:defgeneric clear-dd_int32 (proto))
(cl:defmethod clear-dd_int32 ((self Test1Proto))
  (cl:setf (cl:slot-value self 'dd_int32) 12)
  (cl:setf
    (cl:ldb (cl:byte 1 29) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dd_int32)

(cl:defgeneric clear-dd_string (proto))
(cl:defmethod clear-dd_string ((self Test1Proto))
  (cl:setf (cl:slot-value self 'dd_string) (base:string-to-utf8-octets " f oo "))
  (cl:setf
    (cl:ldb (cl:byte 1 30) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dd_string)

(cl:defgeneric clear-dd_bool (proto))
(cl:defmethod clear-dd_bool ((self Test1Proto))
  (cl:setf (cl:slot-value self 'dd_bool) cl:t)
  (cl:setf
    (cl:ldb (cl:byte 1 31) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dd_bool)

(cl:defmethod clear ((self Test1Proto))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'o_a) 0)
  (cl:setf (cl:slot-value self 'o_b) 0)
  (cl:setf (cl:slot-value self 'u_int32) 0)
  (cl:setf (cl:slot-value self 'u_int64) 0)
  (cl:setf (cl:slot-value self 'u_uint64) 0)
  (cl:setf (cl:slot-value self 'u_fixed32) 0)
  (cl:setf (cl:slot-value self 'u_fixed64) 0)
  (cl:setf (cl:slot-value self 'u_bool) cl:nil)
  (cl:setf (cl:slot-value self 'u_float) 0f0)
  (cl:setf (cl:slot-value self 'u_double) 0d0)
  (cl:setf (cl:slot-value self 'u_string) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'u_vardata) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'u_msg) cl:nil)
  (cl:setf (cl:slot-value self 'r_int32)
           (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_int64)
           (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_uint64)
           (cl:make-array 0 :element-type 'base:uint64 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_fixed32)
           (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_fixed64)
           (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_bool)
           (cl:make-array 0 :element-type 'cl:boolean :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_float)
           (cl:make-array 0 :element-type 'cl:single-float :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_double)
           (cl:make-array 0 :element-type 'cl:double-float :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_string)
           (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_vardata)
           (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r_msg)
           (cl:make-array 0 :element-type 'Test1Msg :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'testgroup1)
           (cl:make-array 0 :element-type 'Test1Proto-TestGroup1 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'testgroup2)
           (cl:make-array 0 :element-type 'Test1Proto-TestGroup2 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'd_int32) 12)
  (cl:setf (cl:slot-value self 'd_string) (base:string-to-utf8-octets "foo"))
  (cl:setf (cl:slot-value self 'd_bool) cl:t)
  (cl:setf (cl:slot-value self 'dd_int32) 12)
  (cl:setf (cl:slot-value self 'dd_string) (base:string-to-utf8-octets " f oo "))
  (cl:setf (cl:slot-value self 'dd_bool) cl:t)
  (cl:values))

(cl:defmethod is-initialized ((self Test1Proto))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b0000000000000000001) #b0000000000000000001))
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 12)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'u_msg))))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'r_msg))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  (cl:let* ((x (cl:slot-value self 'testgroup1))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  (cl:let* ((x (cl:slot-value self 'testgroup2))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self Test1Proto))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int64-to-uint64 (o_a self))))
    (cl:when (has-o_b self) (cl:incf size (cl:+ 1 (varint:length64 (base:int64-to-uint64 (o_b self))))))
    (cl:when (has-u_int32 self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (u_int32 self))))))
    (cl:when (has-u_int64 self) (cl:incf size (cl:+ 1 (varint:length64 (base:int64-to-uint64 (u_int64 self))))))
    (cl:when (has-u_uint64 self) (cl:incf size (cl:+ 1 (varint:length64 (u_uint64 self)))))
    (cl:when (has-u_fixed32 self) (cl:incf size 5))
    (cl:when (has-u_fixed64 self) (cl:incf size 9))
    (cl:when (has-u_bool self) (cl:incf size 2))
    (cl:when (has-u_float self) (cl:incf size 6))
    (cl:when (has-u_double self) (cl:incf size 10))
    (cl:when (has-u_string self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (u_string-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-u_vardata self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (u_vardata-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-u_msg self) (cl:incf size (cl:+ 1 (cl:let ((x (octet-size (u_msg self)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (r_int32 self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int32-to-uint64 (cl:aref (r_int32 self) i))))))
    (cl:let ((length (cl:length (r_int64 self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int64-to-uint64 (cl:aref (r_int64 self) i))))))
    (cl:let ((length (cl:length (r_uint64 self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (cl:aref (r_uint64 self) i)))))
    (cl:incf size (cl:* 5 (cl:length (r_fixed32 self))))
    (cl:incf size (cl:* 10 (cl:length (r_fixed64 self))))
    (cl:incf size (cl:* 3 (cl:length (r_bool self))))
    (cl:incf size (cl:* 6 (cl:length (r_float self))))
    (cl:incf size (cl:* 10 (cl:length (r_double self))))
    (cl:let ((length (cl:length (r_string self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (cl:length (cl:aref (r_string self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (r_vardata self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (cl:length (cl:aref (r_vardata self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (r_msg self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (octet-size (cl:aref (r_msg self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (testgroup1 self))))
      (cl:incf size (cl:* 4 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (testgroup1 self) i)))))
    (cl:let ((length (cl:length (testgroup2 self))))
      (cl:incf size (cl:* 4 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (testgroup2 self) i)))))
    (cl:when (has-d_int32 self) (cl:incf size (cl:+ 2 (varint:length64 (base:int32-to-uint64 (d_int32 self))))))
    (cl:when (has-d_string self) (cl:incf size (cl:+ 2 (cl:let ((x (cl:length (d_string-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-d_bool self) (cl:incf size 3))
    (cl:when (has-dd_int32 self) (cl:incf size (cl:+ 2 (varint:length64 (base:int32-to-uint64 (dd_int32 self))))))
    (cl:when (has-dd_string self) (cl:incf size (cl:+ 2 (cl:let ((x (cl:length (dd_string-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-dd_bool self) (cl:incf size 3))
    (cl:+ size 1)))

(cl:defmethod encode ((pb Test1Proto) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (o_a pb))))
  (cl:when (has-o_b pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (o_b pb))))
    )
  (cl:when (has-u_int32 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (u_int32 pb))))
    )
  (cl:when (has-u_int64 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (u_int64 pb))))
    )
  (cl:when (has-u_uint64 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit (u_uint64 pb)))
    )
  (cl:when (has-u_fixed32 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 53))
    (cl:setf index
     (protocol:write-int32-carefully buffer index limit (u_fixed32 pb)))
    )
  (cl:when (has-u_fixed64 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 57))
    (cl:setf index
     (protocol:write-int64-carefully buffer index limit (u_fixed64 pb)))
    )
  (cl:when (has-u_bool pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 64))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (u_bool pb)))
    )
  (cl:when (has-u_string pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (u_string-octets pb)))
    )
  (cl:when (has-u_vardata pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 82))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (u_vardata-octets pb)))
    )
  (cl:when (has-u_msg pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 90))
    (cl:let ((size (octet-size (u_msg pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (u_msg pb) buffer index limit)))
    )
  (cl:let* ((v (r_int32 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 96))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (cl:aref v i))))
    ))
  (cl:let* ((v (r_int64 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 104))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (cl:aref v i))))
    ))
  (cl:let* ((v (r_uint64 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 112))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_fixed32 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 125))
    (cl:setf index
     (protocol:write-int32-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_fixed64 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 129))
    (cl:setf index
     (protocol:write-int64-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_bool pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 136))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_string pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 146))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_vardata pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 154))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_msg pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 162))
    (cl:let ((size (octet-size (cl:aref v i))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (cl:aref v i) buffer index limit)))
    ))
  (cl:let* ((v (testgroup1 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  (cl:let* ((v (testgroup2 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  (cl:when (has-d_int32 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 200))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (d_int32 pb))))
    )
  (cl:when (has-d_string pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 210))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (d_string-octets pb)))
    )
  (cl:when (has-u_float pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 221))
    (cl:setf index
     (protocol:write-single-float-carefully buffer index limit (u_float pb)))
    )
  (cl:when (has-u_double pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 225))
    (cl:setf index
     (protocol:write-double-float-carefully buffer index limit (u_double pb)))
    )
  (cl:let* ((v (r_float pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 237))
    (cl:setf index
     (protocol:write-single-float-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (r_double pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 241))
    (cl:setf index
     (protocol:write-double-float-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:when (has-d_bool pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 248))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (d_bool pb)))
    )
  (cl:when (has-dd_int32 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 256))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (dd_int32 pb))))
    )
  (cl:when (has-dd_string pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 266))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (dd_string-octets pb)))
    )
  (cl:when (has-dd_bool pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 272))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (dd_bool pb)))
    )
  index)

(cl:defmethod merge ((self Test1Proto) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((8)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'o_a) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((16)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'o_b) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((24)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_int32) value)
              (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((32)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_int64) value)
              (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((40)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-uint64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_uint64) value)
              (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((53)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_fixed32) value)
              (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((57)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_fixed64) value)
              (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((64)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_bool) value)
              (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((221)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-single-float-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_float) value)
              (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((225)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-double-float-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_double) value)
              (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((74)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_string) value)
              (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((82)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'u_vardata) value)
              (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((90)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (u_msg self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          ((96)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_int32))
              (cl:setf index new-index))
          )
          ((104)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_int64))
              (cl:setf index new-index))
          )
          ((112)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-uint64-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_uint64))
              (cl:setf index new-index))
          )
          ((125)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_fixed32))
              (cl:setf index new-index))
          )
          ((129)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int64-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_fixed64))
              (cl:setf index new-index))
          )
          ((136)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_bool))
              (cl:setf index new-index))
          )
          ((237)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-single-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_float))
              (cl:setf index new-index))
          )
          ((241)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-double-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_double))
              (cl:setf index new-index))
          )
          ((146)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_string))
              (cl:setf index new-index))
          )
          ((154)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'r_vardata))
              (cl:setf index new-index))
          )
          ((162)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:let ((new (make-Test1Msg)))
                (cl:setf index (merge new buffer new-index (cl:+ new-index length)))
                (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                  (cl:error "buffer overflow"))
                (cl:vector-push-extend new (cl:slot-value self 'r_msg))))
          )
          ((171)
            (cl:let ((new (make-Test1Proto-TestGroup1)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'testgroup1)))
          )
          ((187)
            (cl:let ((new (make-Test1Proto-TestGroup2)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'testgroup2)))
          )
          ((200)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'd_int32) value)
              (cl:setf (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((210)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'd_string) value)
              (cl:setf (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((248)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'd_bool) value)
              (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((256)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'dd_int32) value)
              (cl:setf (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((266)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'dd_string) value)
              (cl:setf (cl:ldb (cl:byte 1 17) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((272)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'dd_bool) value)
              (cl:setf (cl:ldb (cl:byte 1 18) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test1TrivialProto (protocol-buffer)
  (
  ))

(cl:export 'Test1TrivialProto)


(cl:defun make-Test1TrivialProto ()
  (cl:make-instance 'Test1TrivialProto))
(cl:export 'make-Test1TrivialProto)

(cl:defmethod cl:print-object ((object Test1TrivialProto) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
  )
  (cl:values))

(cl:defmethod clear ((self Test1TrivialProto))
  (cl:values))

(cl:defmethod is-initialized ((self Test1TrivialProto))
  cl:t)

(cl:defmethod octet-size ((self Test1TrivialProto))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:+ size 0)))

(cl:defmethod encode ((pb Test1TrivialProto) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  index)

(cl:defmethod merge ((self Test1TrivialProto) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test2Msg-OptionalGroup (protocol-buffer)
  (
    (c
     :initform 0
     :type base:int64)

    (d
     :initform 0
     :type base:uint64)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'Test2Msg-OptionalGroup)


(cl:defun make-Test2Msg-OptionalGroup ()
  (cl:make-instance 'Test2Msg-OptionalGroup))
(cl:export 'make-Test2Msg-OptionalGroup)

(cl:defgeneric c (proto))
(cl:defmethod c ((self Test2Msg-OptionalGroup))
  (cl:slot-value self 'c))

(cl:defgeneric (cl:setf c) (new-value proto))
(cl:defmethod (cl:setf c) (new-value (self Test2Msg-OptionalGroup))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'c) new-value))

(cl:export 'c)

(cl:defgeneric d (proto))
(cl:defmethod d ((self Test2Msg-OptionalGroup))
  (cl:slot-value self 'd))

(cl:defgeneric (cl:setf d) (new-value proto))
(cl:defmethod (cl:setf d) (new-value (self Test2Msg-OptionalGroup))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'd) new-value))

(cl:export 'd)

(cl:defgeneric has-c (proto))
(cl:defmethod has-c ((self Test2Msg-OptionalGroup))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-c)

(cl:defgeneric has-d (proto))
(cl:defmethod has-d ((self Test2Msg-OptionalGroup))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-d)

(cl:defmethod cl:print-object ((object Test2Msg-OptionalGroup) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-c object)
      (cl:format stream "c: ~s " (c object)))
    (cl:when (has-d object)
      (cl:format stream "d: ~s " (d object)))
  )
  (cl:values))

(cl:defgeneric clear-c (proto))
(cl:defmethod clear-c ((self Test2Msg-OptionalGroup))
  (cl:setf (cl:slot-value self 'c) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-c)

(cl:defgeneric clear-d (proto))
(cl:defmethod clear-d ((self Test2Msg-OptionalGroup))
  (cl:setf (cl:slot-value self 'd) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d)

(cl:defmethod clear ((self Test2Msg-OptionalGroup))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'c) 0)
  (cl:setf (cl:slot-value self 'd) 0)
  (cl:values))

(cl:defmethod is-initialized ((self Test2Msg-OptionalGroup))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b001) #b001))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self Test2Msg-OptionalGroup))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int64-to-uint64 (c self))))
    (cl:when (has-d self) (cl:incf size (cl:+ 1 (varint:length64 (d self)))))
    (cl:+ size 1)))

(cl:defmethod encode ((pb Test2Msg-OptionalGroup) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 19))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (c pb))))
  (cl:when (has-d pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit (d pb)))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 20))
  index)

(cl:defmethod merge ((self Test2Msg-OptionalGroup) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((20)
           (cl:return-from merge index))
          ((24)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'c) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((32)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-uint64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'd) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test2Msg-RepeatedGroup (protocol-buffer)
  (
    (e
     :initform cl:nil
     :type cl:boolean)

    (f
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'Test2Msg-RepeatedGroup)


(cl:defun make-Test2Msg-RepeatedGroup ()
  (cl:make-instance 'Test2Msg-RepeatedGroup))
(cl:export 'make-Test2Msg-RepeatedGroup)

(cl:defgeneric e (proto))
(cl:defmethod e ((self Test2Msg-RepeatedGroup))
  (cl:slot-value self 'e))

(cl:defgeneric (cl:setf e) (new-value proto))
(cl:defmethod (cl:setf e) (new-value (self Test2Msg-RepeatedGroup))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'e) new-value))

(cl:export 'e)

(cl:defgeneric f (proto))
(cl:defmethod f ((self Test2Msg-RepeatedGroup))
  (base:utf8-octets-to-string (cl:slot-value self 'f)))
(cl:defgeneric f-octets (proto))
(cl:defmethod f-octets ((self Test2Msg-RepeatedGroup))
  (cl:slot-value self 'f))
(cl:export 'f)

(cl:defgeneric (cl:setf f) (new-value proto))
(cl:defmethod (cl:setf f) (new-value (self Test2Msg-RepeatedGroup))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'f)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'f) new-value))))

(cl:export 'f)

(cl:defgeneric has-e (proto))
(cl:defmethod has-e ((self Test2Msg-RepeatedGroup))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-e)

(cl:defgeneric has-f (proto))
(cl:defmethod has-f ((self Test2Msg-RepeatedGroup))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-f)

(cl:defmethod cl:print-object ((object Test2Msg-RepeatedGroup) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-e object)
      (cl:format stream "e: ~s " (e object)))
    (cl:when (has-f object)
      (cl:format stream "f: ~s " (f object)))
  )
  (cl:values))

(cl:defgeneric clear-e (proto))
(cl:defmethod clear-e ((self Test2Msg-RepeatedGroup))
  (cl:setf (cl:slot-value self 'e) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-e)

(cl:defgeneric clear-f (proto))
(cl:defmethod clear-f ((self Test2Msg-RepeatedGroup))
  (cl:setf (cl:slot-value self 'f) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-f)

(cl:defmethod clear ((self Test2Msg-RepeatedGroup))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'e) cl:nil)
  (cl:setf (cl:slot-value self 'f) (base:make-octet-vector 0))
  (cl:values))

(cl:defmethod is-initialized ((self Test2Msg-RepeatedGroup))
  cl:t)

(cl:defmethod octet-size ((self Test2Msg-RepeatedGroup))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-e self) (cl:incf size 2))
    (cl:when (has-f self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (f-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb Test2Msg-RepeatedGroup) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 43))
  (cl:when (has-e pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (e pb)))
    )
  (cl:when (has-f pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (f-octets pb)))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 44))
  index)

(cl:defmethod merge ((self Test2Msg-RepeatedGroup) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((44)
           (cl:return-from merge index))
          ((48)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'e) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((58)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'f) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test2Msg (protocol-buffer)
  (
    (a
     :initform 0d0
     :type cl:double-float)

    (optionalgroup
     :accessor optionalgroup
     :initform cl:nil
     :type (cl:or cl:null Test2Msg-OptionalGroup))

    (repeatedgroup :accessor repeatedgroup
     :initform (cl:make-array 0 :element-type 'Test2Msg-RepeatedGroup :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector Test2Msg-RepeatedGroup))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'Test2Msg)


(cl:defun make-Test2Msg ()
  (cl:make-instance 'Test2Msg))
(cl:export 'make-Test2Msg)

(cl:defgeneric a (proto))
(cl:defmethod a ((self Test2Msg))
  (cl:slot-value self 'a))

(cl:defgeneric (cl:setf a) (new-value proto))
(cl:defmethod (cl:setf a) (new-value (self Test2Msg))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'a) new-value))

(cl:export 'a)

(cl:defgeneric optionalgroup (proto))
(cl:defmethod optionalgroup ((self Test2Msg))
  (cl:when (cl:null (cl:slot-value self 'optionalgroup))
    (cl:setf
      (cl:ldb (cl:byte 1 1)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'optionalgroup)
             (make-Test2Msg-OptionalGroup)))
  (cl:slot-value self 'optionalgroup))

(cl:defgeneric (cl:setf optionalgroup) (new-value proto))
(cl:defmethod (cl:setf optionalgroup) (new-value (self Test2Msg))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'optionalgroup) new-value))

(cl:export 'optionalgroup)

(cl:export 'repeatedgroup)

(cl:defgeneric has-a (proto))
(cl:defmethod has-a ((self Test2Msg))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-a)

(cl:defgeneric has-optionalgroup (proto))
(cl:defmethod has-optionalgroup ((self Test2Msg))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-optionalgroup)

(cl:defmethod cl:print-object ((object Test2Msg) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-a object)
      (cl:format stream "a: ~s " (a object)))
    (cl:when (has-optionalgroup object)
      (cl:format stream "optionalgroup: ~s " (optionalgroup object)))
    (cl:format stream "repeatedgroup: ~s " (repeatedgroup object))
  )
  (cl:values))

(cl:defgeneric clear-a (proto))
(cl:defmethod clear-a ((self Test2Msg))
  (cl:setf (cl:slot-value self 'a) 0d0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-a)

(cl:defgeneric clear-optionalgroup (proto))
(cl:defmethod clear-optionalgroup ((self Test2Msg))
  (cl:setf (cl:slot-value self 'optionalgroup) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-optionalgroup)

(cl:defmethod clear ((self Test2Msg))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'a) 0d0)
  (cl:setf (cl:slot-value self 'optionalgroup) cl:nil)
  (cl:setf (cl:slot-value self 'repeatedgroup)
           (cl:make-array 0 :element-type 'Test2Msg-RepeatedGroup :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self Test2Msg))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b01) #b01))
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 1)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'optionalgroup))))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'repeatedgroup))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self Test2Msg))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-optionalgroup self) (cl:incf size (cl:+ 2 (octet-size (optionalgroup self)))))
    (cl:let ((length (cl:length (repeatedgroup self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (repeatedgroup self) i)))))
    (cl:+ size 9)))

(cl:defmethod encode ((pb Test2Msg) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 9))
    (cl:setf index
     (protocol:write-double-float-carefully buffer index limit (a pb)))
  (cl:when (has-optionalgroup pb)
    (cl:setf index (encode (optionalgroup pb) buffer index limit))
    )
  (cl:let* ((v (repeatedgroup pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  index)

(cl:defmethod merge ((self Test2Msg) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((9)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-double-float-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'a) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((19)
            (cl:let ((new-index (merge (optionalgroup self) buffer index limit)))
              (cl:setf index new-index))
          )
          ((43)
            (cl:let ((new (make-Test2Msg-RepeatedGroup)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'repeatedgroup)))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass Test2Proto (protocol-buffer)
  (
    (a
     :initform 0
     :type base:int32)

    (b
     :initform 0
     :type base:int64)

    (c :accessor c
     :initform (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int32))

    (repeatedmsg :accessor repeatedmsg
     :initform (cl:make-array 0 :element-type 'Test2Msg :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector Test2Msg))

    (optionalmsg
     :accessor optionalmsg
     :initform cl:nil
     :type (cl:or cl:null Test2Msg))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 3))
  ))

(cl:export 'Test2Proto)


(cl:defun make-Test2Proto ()
  (cl:make-instance 'Test2Proto))
(cl:export 'make-Test2Proto)

(cl:defgeneric a (proto))
(cl:defmethod a ((self Test2Proto))
  (cl:slot-value self 'a))

(cl:defgeneric (cl:setf a) (new-value proto))
(cl:defmethod (cl:setf a) (new-value (self Test2Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'a) new-value))

(cl:export 'a)

(cl:defgeneric b (proto))
(cl:defmethod b ((self Test2Proto))
  (cl:slot-value self 'b))

(cl:defgeneric (cl:setf b) (new-value proto))
(cl:defmethod (cl:setf b) (new-value (self Test2Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'b) new-value))

(cl:export 'b)

(cl:export 'c)

(cl:export 'repeatedmsg)

(cl:defgeneric optionalmsg (proto))
(cl:defmethod optionalmsg ((self Test2Proto))
  (cl:when (cl:null (cl:slot-value self 'optionalmsg))
    (cl:setf
      (cl:ldb (cl:byte 1 2)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'optionalmsg)
             (make-Test2Msg)))
  (cl:slot-value self 'optionalmsg))

(cl:defgeneric (cl:setf optionalmsg) (new-value proto))
(cl:defmethod (cl:setf optionalmsg) (new-value (self Test2Proto))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'optionalmsg) new-value))

(cl:export 'optionalmsg)

(cl:defgeneric has-a (proto))
(cl:defmethod has-a ((self Test2Proto))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-a)

(cl:defgeneric has-b (proto))
(cl:defmethod has-b ((self Test2Proto))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-b)

(cl:defgeneric has-optionalmsg (proto))
(cl:defmethod has-optionalmsg ((self Test2Proto))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-optionalmsg)

(cl:defmethod cl:print-object ((object Test2Proto) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-a object)
      (cl:format stream "a: ~s " (a object)))
    (cl:when (has-b object)
      (cl:format stream "b: ~s " (b object)))
    (cl:format stream "c: ~s " (c object))
    (cl:format stream "repeatedmsg: ~s " (repeatedmsg object))
    (cl:when (has-optionalmsg object)
      (cl:format stream "optionalmsg: ~s " (optionalmsg object)))
  )
  (cl:values))

(cl:defgeneric clear-a (proto))
(cl:defmethod clear-a ((self Test2Proto))
  (cl:setf (cl:slot-value self 'a) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-a)

(cl:defgeneric clear-b (proto))
(cl:defmethod clear-b ((self Test2Proto))
  (cl:setf (cl:slot-value self 'b) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-b)

(cl:defgeneric clear-optionalmsg (proto))
(cl:defmethod clear-optionalmsg ((self Test2Proto))
  (cl:setf (cl:slot-value self 'optionalmsg) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-optionalmsg)

(cl:defmethod clear ((self Test2Proto))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'a) 0)
  (cl:setf (cl:slot-value self 'b) 0)
  (cl:setf (cl:slot-value self 'c)
           (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'repeatedmsg)
           (cl:make-array 0 :element-type 'Test2Msg :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'optionalmsg) cl:nil)
  (cl:values))

(cl:defmethod is-initialized ((self Test2Proto))
  (cl:let* ((x (cl:slot-value self 'repeatedmsg))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 2)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'optionalmsg))))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self Test2Proto))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-a self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (a self))))))
    (cl:when (has-b self) (cl:incf size 9))
    (cl:incf size (cl:* 5 (cl:length (c self))))
    (cl:let ((length (cl:length (repeatedmsg self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (octet-size (cl:aref (repeatedmsg self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-optionalmsg self) (cl:incf size (cl:+ 1 (cl:let ((x (octet-size (optionalmsg self)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb Test2Proto) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:when (has-a pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (a pb))))
    )
  (cl:when (has-b pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 17))
    (cl:setf index
     (protocol:write-int64-carefully buffer index limit (b pb)))
    )
  (cl:let* ((v (c pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 29))
    (cl:setf index
     (protocol:write-int32-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (repeatedmsg pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
    (cl:let ((size (octet-size (cl:aref v i))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (cl:aref v i) buffer index limit)))
    ))
  (cl:when (has-optionalmsg pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:let ((size (octet-size (optionalmsg pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (optionalmsg pb) buffer index limit)))
    )
  index)

(cl:defmethod merge ((self Test2Proto) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((8)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'a) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((17)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'b) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((29)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'c))
              (cl:setf index new-index))
          )
          ((50)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:let ((new (make-Test2Msg)))
                (cl:setf index (merge new buffer new-index (cl:+ new-index length)))
                (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                  (cl:error "buffer overflow"))
                (cl:vector-push-extend new (cl:slot-value self 'repeatedmsg))))
          )
          ((58)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (optionalmsg self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestPythonDebugOutput (protocol-buffer)
  (
    (a :accessor a
     :initform (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int32))

    (b :accessor b
     :initform (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int64))

    (c
     :initform 0
     :type base:int32)

    (d
     :initform 0
     :type base:int64)

    (e
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (f :accessor f
     :initform (cl:make-array 0 :element-type 'cl:boolean :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:boolean))

    (g
     :initform 0f0
     :type cl:single-float)

    (h
     :initform 0d0
     :type cl:double-float)

    (camelcasename
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 6))
  ))

(cl:export 'TestPythonDebugOutput)


(cl:defun make-TestPythonDebugOutput ()
  (cl:make-instance 'TestPythonDebugOutput))
(cl:export 'make-TestPythonDebugOutput)

(cl:export 'a)

(cl:export 'b)

(cl:defgeneric c (proto))
(cl:defmethod c ((self TestPythonDebugOutput))
  (cl:slot-value self 'c))

(cl:defgeneric (cl:setf c) (new-value proto))
(cl:defmethod (cl:setf c) (new-value (self TestPythonDebugOutput))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'c) new-value))

(cl:export 'c)

(cl:defgeneric d (proto))
(cl:defmethod d ((self TestPythonDebugOutput))
  (cl:slot-value self 'd))

(cl:defgeneric (cl:setf d) (new-value proto))
(cl:defmethod (cl:setf d) (new-value (self TestPythonDebugOutput))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'd) new-value))

(cl:export 'd)

(cl:defgeneric e (proto))
(cl:defmethod e ((self TestPythonDebugOutput))
  (base:utf8-octets-to-string (cl:slot-value self 'e)))
(cl:defgeneric e-octets (proto))
(cl:defmethod e-octets ((self TestPythonDebugOutput))
  (cl:slot-value self 'e))
(cl:export 'e)

(cl:defgeneric (cl:setf e) (new-value proto))
(cl:defmethod (cl:setf e) (new-value (self TestPythonDebugOutput))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'e)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'e) new-value))))

(cl:export 'e)

(cl:export 'f)

(cl:defgeneric g (proto))
(cl:defmethod g ((self TestPythonDebugOutput))
  (cl:slot-value self 'g))

(cl:defgeneric (cl:setf g) (new-value proto))
(cl:defmethod (cl:setf g) (new-value (self TestPythonDebugOutput))
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'g) new-value))

(cl:export 'g)

(cl:defgeneric h (proto))
(cl:defmethod h ((self TestPythonDebugOutput))
  (cl:slot-value self 'h))

(cl:defgeneric (cl:setf h) (new-value proto))
(cl:defmethod (cl:setf h) (new-value (self TestPythonDebugOutput))
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'h) new-value))

(cl:export 'h)

(cl:defgeneric camelcasename (proto))
(cl:defmethod camelcasename ((self TestPythonDebugOutput))
  (base:utf8-octets-to-string (cl:slot-value self 'camelcasename)))
(cl:defgeneric camelcasename-octets (proto))
(cl:defmethod camelcasename-octets ((self TestPythonDebugOutput))
  (cl:slot-value self 'camelcasename))
(cl:export 'camelcasename)

(cl:defgeneric (cl:setf camelcasename) (new-value proto))
(cl:defmethod (cl:setf camelcasename) (new-value (self TestPythonDebugOutput))
  (cl:setf
    (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'camelcasename)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'camelcasename) new-value))))

(cl:export 'camelcasename)

(cl:defgeneric has-c (proto))
(cl:defmethod has-c ((self TestPythonDebugOutput))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-c)

(cl:defgeneric has-d (proto))
(cl:defmethod has-d ((self TestPythonDebugOutput))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-d)

(cl:defgeneric has-e (proto))
(cl:defmethod has-e ((self TestPythonDebugOutput))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-e)

(cl:defgeneric has-g (proto))
(cl:defmethod has-g ((self TestPythonDebugOutput))
  (cl:= (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-g)

(cl:defgeneric has-h (proto))
(cl:defmethod has-h ((self TestPythonDebugOutput))
  (cl:= (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-h)

(cl:defgeneric has-camelcasename (proto))
(cl:defmethod has-camelcasename ((self TestPythonDebugOutput))
  (cl:= (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-camelcasename)

(cl:defmethod cl:print-object ((object TestPythonDebugOutput) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:format stream "a: ~s " (a object))
    (cl:format stream "b: ~s " (b object))
    (cl:when (has-c object)
      (cl:format stream "c: ~s " (c object)))
    (cl:when (has-d object)
      (cl:format stream "d: ~s " (d object)))
    (cl:when (has-e object)
      (cl:format stream "e: ~s " (e object)))
    (cl:format stream "f: ~s " (f object))
    (cl:when (has-g object)
      (cl:format stream "g: ~s " (g object)))
    (cl:when (has-h object)
      (cl:format stream "h: ~s " (h object)))
    (cl:when (has-camelcasename object)
      (cl:format stream "camelcasename: ~s " (camelcasename object)))
  )
  (cl:values))

(cl:defgeneric clear-c (proto))
(cl:defmethod clear-c ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self 'c) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-c)

(cl:defgeneric clear-d (proto))
(cl:defmethod clear-d ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self 'd) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d)

(cl:defgeneric clear-e (proto))
(cl:defmethod clear-e ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self 'e) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-e)

(cl:defgeneric clear-g (proto))
(cl:defmethod clear-g ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self 'g) 0f0)
  (cl:setf
    (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-g)

(cl:defgeneric clear-h (proto))
(cl:defmethod clear-h ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self 'h) 0d0)
  (cl:setf
    (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-h)

(cl:defgeneric clear-camelcasename (proto))
(cl:defmethod clear-camelcasename ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self 'camelcasename) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-camelcasename)

(cl:defmethod clear ((self TestPythonDebugOutput))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'a)
           (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'b)
           (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'c) 0)
  (cl:setf (cl:slot-value self 'd) 0)
  (cl:setf (cl:slot-value self 'e) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'f)
           (cl:make-array 0 :element-type 'cl:boolean :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'g) 0f0)
  (cl:setf (cl:slot-value self 'h) 0d0)
  (cl:setf (cl:slot-value self 'camelcasename) (base:make-octet-vector 0))
  (cl:values))

(cl:defmethod is-initialized ((self TestPythonDebugOutput))
  cl:t)

(cl:defmethod octet-size ((self TestPythonDebugOutput))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:let ((length (cl:length (a self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int32-to-uint64 (cl:aref (a self) i))))))
    (cl:let ((length (cl:length (b self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int64-to-uint64 (cl:aref (b self) i))))))
    (cl:when (has-c self) (cl:incf size 5))
    (cl:when (has-d self) (cl:incf size 9))
    (cl:when (has-e self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (e-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:incf size (cl:* 2 (cl:length (f self))))
    (cl:when (has-g self) (cl:incf size 5))
    (cl:when (has-h self) (cl:incf size 9))
    (cl:when (has-camelcasename self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (camelcasename-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestPythonDebugOutput) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:let* ((v (a pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (cl:aref v i))))
    ))
  (cl:let* ((v (b pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (cl:aref v i))))
    ))
  (cl:when (has-c pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 29))
    (cl:setf index
     (protocol:write-int32-carefully buffer index limit (c pb)))
    )
  (cl:when (has-d pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 33))
    (cl:setf index
     (protocol:write-int64-carefully buffer index limit (d pb)))
    )
  (cl:when (has-e pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (e-octets pb)))
    )
  (cl:let* ((v (f pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:when (has-g pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 61))
    (cl:setf index
     (protocol:write-single-float-carefully buffer index limit (g pb)))
    )
  (cl:when (has-h pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 65))
    (cl:setf index
     (protocol:write-double-float-carefully buffer index limit (h pb)))
    )
  (cl:when (has-camelcasename pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (camelcasename-octets pb)))
    )
  index)

(cl:defmethod merge ((self TestPythonDebugOutput) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((8)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'a))
              (cl:setf index new-index))
          )
          ((16)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'b))
              (cl:setf index new-index))
          )
          ((29)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'c) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((33)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'd) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((42)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'e) value)
              (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((48)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'f))
              (cl:setf index new-index))
          )
          ((61)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-single-float-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'g) value)
              (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((65)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-double-float-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'h) value)
              (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((74)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'camelcasename) value)
              (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

