
;;;;    testproto1.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:protocol-buffer)

(cl:deftype test1proto-enumcode () '(cl:member 0 1 2))
(cl:export 'test1proto-enumcode)

(cl:defconstant +test1proto-enumcode-foo+ 0)
(cl:export '+test1proto-enumcode-foo+)
(cl:defconstant +test1proto-enumcode-bar+ 1)
(cl:export '+test1proto-enumcode-bar+)
(cl:defconstant +test1proto-enumcode-baz+ 2)
(cl:export '+test1proto-enumcode-baz+)

(cl:defconstant +minimum-test1proto-enumcode+ +test1proto-enumcode-foo+)
(cl:export '+minimum-test1proto-enumcode+)
(cl:defconstant +maximum-test1proto-enumcode+ +test1proto-enumcode-baz+)
(cl:export '+maximum-test1proto-enumcode+)

(cl:defclass test1msg (protocol-buffer)
  (
  (foo
   :accessor foo
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'test1msg)

(cl:export 'foo)


(cl:defmethod (cl:setf foo) :after (x (self test1msg))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-foo (proto))
(cl:defmethod has-foo ((self test1msg))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-foo)

(cl:defgeneric clear-foo (proto))
(cl:defmethod clear-foo ((self test1msg))
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-foo)


(cl:defmethod cl:print-object ((self test1msg) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "foo: ~s " (cl:slot-value self 'foo)))
    )
  (cl:values))

(cl:defmethod clear ((self test1msg))
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self test1msg))
  cl:t)

(cl:defmethod octet-size ((self test1msg))
  (cl:let ((size 0))
    ;; optional int32 foo = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'foo))))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self test1msg) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int32 foo = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'foo)))))
  index)


(cl:defclass test1proto-testgroup1 (protocol-buffer)
  (
  (a
   :accessor a
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'test1proto-testgroup1)

(cl:export 'a)


(cl:defmethod (cl:setf a) :after (x (self test1proto-testgroup1))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-a (proto))
(cl:defmethod has-a ((self test1proto-testgroup1))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-a)

(cl:defgeneric clear-a (proto))
(cl:defmethod clear-a ((self test1proto-testgroup1))
  (cl:setf (cl:slot-value self 'a) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-a)



(cl:defclass test1proto-testgroup2 (protocol-buffer)
  (
  (b
   :accessor b
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'test1proto-testgroup2)

(cl:export 'b)


(cl:defmethod (cl:setf b) :after (x (self test1proto-testgroup2))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-b (proto))
(cl:defmethod has-b ((self test1proto-testgroup2))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-b)

(cl:defgeneric clear-b (proto))
(cl:defmethod clear-b ((self test1proto-testgroup2))
  (cl:setf (cl:slot-value self 'b) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-b)



(cl:defclass test1proto (protocol-buffer)
  (
  (o-a
   :accessor o-a
   :initform 0
   :type (cl:signed-byte 64))
  (o-b
   :accessor o-b
   :initform 0
   :type (cl:signed-byte 64))
  (u-int32
   :accessor u-int32
   :initform 0
   :type (cl:signed-byte 32))
  (u-int64
   :accessor u-int64
   :initform 0
   :type (cl:signed-byte 64))
  (u-uint64
   :accessor u-uint64
   :initform 0
   :type (cl:unsigned-byte 64))
  (u-fixed32
   :accessor u-fixed32
   :initform 0
   :type (cl:unsigned-byte 32))
  (u-fixed64
   :accessor u-fixed64
   :initform 0
   :type (cl:unsigned-byte 64))
  (u-bool
   :accessor u-bool
   :initform cl:nil
   :type cl:boolean)
  (u-float
   :accessor u-float
   :initform 0s0
   :type cl:single-float)
  (u-double
   :accessor u-double
   :initform 0d0
   :type cl:double-float)
  (u-string
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '())
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (u-vardata
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '())
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (u-msg
   :writer (cl:setf u-msg)
   :initform cl:nil
   :type (cl:or cl:null test1msg))
  (r-int32
   :accessor r-int32
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 32)))
  (r-int64
   :accessor r-int64
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 64)))
  (r-uint64
   :accessor r-uint64
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:unsigned-byte 64)))
  (r-fixed32
   :accessor r-fixed32
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:unsigned-byte 32)))
  (r-fixed64
   :accessor r-fixed64
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:unsigned-byte 64)))
  (r-bool
   :accessor r-bool
   :initform (cl:make-array
              0
              :element-type 'cl:boolean
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:boolean))
  (r-float
   :accessor r-float
   :initform (cl:make-array
              0
              :element-type 'cl:single-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:single-float))
  (r-double
   :accessor r-double
   :initform (cl:make-array
              0
              :element-type 'cl:double-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:double-float))
  (r-string
   :accessor r-string
   :initform (cl:make-array
              0
              :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:simple-array (cl:unsigned-byte 8) (cl:*))))
  (r-vardata
   :accessor r-vardata
   :initform (cl:make-array
              0
              :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:simple-array (cl:unsigned-byte 8) (cl:*))))
  (r-msg
   :accessor r-msg
   :initform (cl:make-array
              0
              :element-type 'test1msg
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector test1msg))
  (testgroup1
   :accessor testgroup1
   :initform (cl:make-array
              0
              :element-type 'test1proto-testgroup1
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector test1proto-testgroup1))
  (testgroup2
   :accessor testgroup2
   :initform (cl:make-array
              0
              :element-type 'test1proto-testgroup2
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector test1proto-testgroup2))
  (d-int32
   :accessor d-int32
   :initform 12
   :type (cl:signed-byte 32))
  (d-string
   :initform (cl:make-array
              3
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '(102 111 111))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (d-bool
   :accessor d-bool
   :initform cl:t
   :type cl:boolean)
  (dd-int32
   :accessor dd-int32
   :initform 12
   :type (cl:signed-byte 32))
  (dd-string
   :initform (cl:make-array
              6
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '(32 102 32 111 111 32))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (dd-bool
   :accessor dd-bool
   :initform cl:t
   :type cl:boolean)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 32))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'test1proto)

(cl:export 'o-a)


(cl:defmethod (cl:setf o-a) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-o-a (proto))
(cl:defmethod has-o-a ((self test1proto))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-o-a)

(cl:defgeneric clear-o-a (proto))
(cl:defmethod clear-o-a ((self test1proto))
  (cl:setf (cl:slot-value self 'o-a) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-o-a)

(cl:export 'o-b)


(cl:defmethod (cl:setf o-b) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-o-b (proto))
(cl:defmethod has-o-b ((self test1proto))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-o-b)

(cl:defgeneric clear-o-b (proto))
(cl:defmethod clear-o-b ((self test1proto))
  (cl:setf (cl:slot-value self 'o-b) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-o-b)

(cl:export 'u-int32)


(cl:defmethod (cl:setf u-int32) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-int32 (proto))
(cl:defmethod has-u-int32 ((self test1proto))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-int32)

(cl:defgeneric clear-u-int32 (proto))
(cl:defmethod clear-u-int32 ((self test1proto))
  (cl:setf (cl:slot-value self 'u-int32) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-int32)

(cl:export 'u-int64)


(cl:defmethod (cl:setf u-int64) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-int64 (proto))
(cl:defmethod has-u-int64 ((self test1proto))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-int64)

(cl:defgeneric clear-u-int64 (proto))
(cl:defmethod clear-u-int64 ((self test1proto))
  (cl:setf (cl:slot-value self 'u-int64) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-int64)

(cl:export 'u-uint64)


(cl:defmethod (cl:setf u-uint64) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-uint64 (proto))
(cl:defmethod has-u-uint64 ((self test1proto))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-uint64)

(cl:defgeneric clear-u-uint64 (proto))
(cl:defmethod clear-u-uint64 ((self test1proto))
  (cl:setf (cl:slot-value self 'u-uint64) 0)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-uint64)

(cl:export 'u-fixed32)


(cl:defmethod (cl:setf u-fixed32) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-fixed32 (proto))
(cl:defmethod has-u-fixed32 ((self test1proto))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-fixed32)

(cl:defgeneric clear-u-fixed32 (proto))
(cl:defmethod clear-u-fixed32 ((self test1proto))
  (cl:setf (cl:slot-value self 'u-fixed32) 0)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-fixed32)

(cl:export 'u-fixed64)


(cl:defmethod (cl:setf u-fixed64) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-fixed64 (proto))
(cl:defmethod has-u-fixed64 ((self test1proto))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-fixed64)

(cl:defgeneric clear-u-fixed64 (proto))
(cl:defmethod clear-u-fixed64 ((self test1proto))
  (cl:setf (cl:slot-value self 'u-fixed64) 0)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-fixed64)

(cl:export 'u-bool)


(cl:defmethod (cl:setf u-bool) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-bool (proto))
(cl:defmethod has-u-bool ((self test1proto))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-bool)

(cl:defgeneric clear-u-bool (proto))
(cl:defmethod clear-u-bool ((self test1proto))
  (cl:setf (cl:slot-value self 'u-bool) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-bool)

(cl:export 'u-float)


(cl:defmethod (cl:setf u-float) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-float (proto))
(cl:defmethod has-u-float ((self test1proto))
  (cl:logbitp 8 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-float)

(cl:defgeneric clear-u-float (proto))
(cl:defmethod clear-u-float ((self test1proto))
  (cl:setf (cl:slot-value self 'u-float) 0s0)
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-float)

(cl:export 'u-double)


(cl:defmethod (cl:setf u-double) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-double (proto))
(cl:defmethod has-u-double ((self test1proto))
  (cl:logbitp 9 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-double)

(cl:defgeneric clear-u-double (proto))
(cl:defmethod clear-u-double ((self test1proto))
  (cl:setf (cl:slot-value self 'u-double) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-double)

(cl:export 'u-string)

(cl:defgeneric u-string (proto))
(cl:defmethod u-string ((self test1proto))
  (base:utf8-octets-to-string (cl:slot-value self 'u-string)))

(cl:export 'u-string-octets)
(cl:defgeneric u-string-octets (proto))
(cl:defmethod u-string-octets ((self test1proto))
  (cl:slot-value self 'u-string))

(cl:defgeneric (cl:setf u-string) (new-value proto))
(cl:defmethod (cl:setf u-string) (new-value (self test1proto))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'u-string)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'u-string) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf u-string) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-string (proto))
(cl:defmethod has-u-string ((self test1proto))
  (cl:logbitp 10 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-string)

(cl:defgeneric clear-u-string (proto))
(cl:defmethod clear-u-string ((self test1proto))
  (cl:setf (cl:slot-value self 'u-string)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
            :initial-contents '()))
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-string)

(cl:export 'u-vardata)

(cl:defgeneric u-vardata (proto))
(cl:defmethod u-vardata ((self test1proto))
  (base:utf8-octets-to-string (cl:slot-value self 'u-vardata)))

(cl:export 'u-vardata-octets)
(cl:defgeneric u-vardata-octets (proto))
(cl:defmethod u-vardata-octets ((self test1proto))
  (cl:slot-value self 'u-vardata))

(cl:defgeneric (cl:setf u-vardata) (new-value proto))
(cl:defmethod (cl:setf u-vardata) (new-value (self test1proto))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'u-vardata)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'u-vardata) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf u-vardata) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-vardata (proto))
(cl:defmethod has-u-vardata ((self test1proto))
  (cl:logbitp 11 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-vardata)

(cl:defgeneric clear-u-vardata (proto))
(cl:defmethod clear-u-vardata ((self test1proto))
  (cl:setf (cl:slot-value self 'u-vardata)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
            :initial-contents '()))
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-vardata)

(cl:export 'u-msg)

(cl:defgeneric u-msg (proto))
(cl:defmethod u-msg ((self test1proto))
  (cl:let ((result (cl:slot-value self 'u-msg)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'test1msg))
      (cl:setf (cl:slot-value self 'u-msg) result))
      (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf u-msg) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-u-msg (proto))
(cl:defmethod has-u-msg ((self test1proto))
  (cl:logbitp 12 (cl:slot-value self '%has-bits%)))
(cl:export 'has-u-msg)

(cl:defgeneric clear-u-msg (proto))
(cl:defmethod clear-u-msg ((self test1proto))
  (cl:setf (cl:slot-value self 'u-msg) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-u-msg)

(cl:export 'r-int32)

(cl:defgeneric clear-r-int32 (proto))
(cl:defmethod clear-r-int32 ((self test1proto))
  (cl:setf (cl:slot-value self 'r-int32)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-int32)

(cl:export 'r-int64)

(cl:defgeneric clear-r-int64 (proto))
(cl:defmethod clear-r-int64 ((self test1proto))
  (cl:setf (cl:slot-value self 'r-int64)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-int64)

(cl:export 'r-uint64)

(cl:defgeneric clear-r-uint64 (proto))
(cl:defmethod clear-r-uint64 ((self test1proto))
  (cl:setf (cl:slot-value self 'r-uint64)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-uint64)

(cl:export 'r-fixed32)

(cl:defgeneric clear-r-fixed32 (proto))
(cl:defmethod clear-r-fixed32 ((self test1proto))
  (cl:setf (cl:slot-value self 'r-fixed32)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-fixed32)

(cl:export 'r-fixed64)

(cl:defgeneric clear-r-fixed64 (proto))
(cl:defmethod clear-r-fixed64 ((self test1proto))
  (cl:setf (cl:slot-value self 'r-fixed64)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-fixed64)

(cl:export 'r-bool)

(cl:defgeneric clear-r-bool (proto))
(cl:defmethod clear-r-bool ((self test1proto))
  (cl:setf (cl:slot-value self 'r-bool)
           (cl:make-array 0 :element-type 'cl:boolean
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-bool)

(cl:export 'r-float)

(cl:defgeneric clear-r-float (proto))
(cl:defmethod clear-r-float ((self test1proto))
  (cl:setf (cl:slot-value self 'r-float)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-float)

(cl:export 'r-double)

(cl:defgeneric clear-r-double (proto))
(cl:defmethod clear-r-double ((self test1proto))
  (cl:setf (cl:slot-value self 'r-double)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-double)

(cl:export 'r-string)

(cl:defgeneric clear-r-string (proto))
(cl:defmethod clear-r-string ((self test1proto))
  (cl:setf (cl:slot-value self 'r-string)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-string)

(cl:export 'r-vardata)

(cl:defgeneric clear-r-vardata (proto))
(cl:defmethod clear-r-vardata ((self test1proto))
  (cl:setf (cl:slot-value self 'r-vardata)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-vardata)

(cl:export 'r-msg)

(cl:defgeneric clear-r-msg (proto))
(cl:defmethod clear-r-msg ((self test1proto))
  (cl:setf (cl:slot-value self 'r-msg)
           (cl:make-array 0 :element-type 'test1msg
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-r-msg)

(cl:export 'testgroup1)

(cl:defgeneric clear-testgroup1 (proto))
(cl:defmethod clear-testgroup1 ((self test1proto))
  (cl:setf (cl:slot-value self 'testgroup1)
           (cl:make-array 0 :element-type 'test1proto-testgroup1
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-testgroup1)

(cl:export 'testgroup2)

(cl:defgeneric clear-testgroup2 (proto))
(cl:defmethod clear-testgroup2 ((self test1proto))
  (cl:setf (cl:slot-value self 'testgroup2)
           (cl:make-array 0 :element-type 'test1proto-testgroup2
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-testgroup2)

(cl:export 'd-int32)


(cl:defmethod (cl:setf d-int32) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 26) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-d-int32 (proto))
(cl:defmethod has-d-int32 ((self test1proto))
  (cl:logbitp 26 (cl:slot-value self '%has-bits%)))
(cl:export 'has-d-int32)

(cl:defgeneric clear-d-int32 (proto))
(cl:defmethod clear-d-int32 ((self test1proto))
  (cl:setf (cl:slot-value self 'd-int32) 12)
  (cl:setf (cl:ldb (cl:byte 1 26) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d-int32)

(cl:export 'd-string)

(cl:defgeneric d-string (proto))
(cl:defmethod d-string ((self test1proto))
  (base:utf8-octets-to-string (cl:slot-value self 'd-string)))

(cl:export 'd-string-octets)
(cl:defgeneric d-string-octets (proto))
(cl:defmethod d-string-octets ((self test1proto))
  (cl:slot-value self 'd-string))

(cl:defgeneric (cl:setf d-string) (new-value proto))
(cl:defmethod (cl:setf d-string) (new-value (self test1proto))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'd-string)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'd-string) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 27) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf d-string) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 27) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-d-string (proto))
(cl:defmethod has-d-string ((self test1proto))
  (cl:logbitp 27 (cl:slot-value self '%has-bits%)))
(cl:export 'has-d-string)

(cl:defgeneric clear-d-string (proto))
(cl:defmethod clear-d-string ((self test1proto))
  (cl:setf (cl:slot-value self 'd-string)
           (cl:make-array 3 :element-type '(cl:unsigned-byte 8)
            :initial-contents '(102 111 111)))
  (cl:setf (cl:ldb (cl:byte 1 27) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d-string)

(cl:export 'd-bool)


(cl:defmethod (cl:setf d-bool) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 28) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-d-bool (proto))
(cl:defmethod has-d-bool ((self test1proto))
  (cl:logbitp 28 (cl:slot-value self '%has-bits%)))
(cl:export 'has-d-bool)

(cl:defgeneric clear-d-bool (proto))
(cl:defmethod clear-d-bool ((self test1proto))
  (cl:setf (cl:slot-value self 'd-bool) cl:t)
  (cl:setf (cl:ldb (cl:byte 1 28) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-d-bool)

(cl:export 'dd-int32)


(cl:defmethod (cl:setf dd-int32) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 29) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-dd-int32 (proto))
(cl:defmethod has-dd-int32 ((self test1proto))
  (cl:logbitp 29 (cl:slot-value self '%has-bits%)))
(cl:export 'has-dd-int32)

(cl:defgeneric clear-dd-int32 (proto))
(cl:defmethod clear-dd-int32 ((self test1proto))
  (cl:setf (cl:slot-value self 'dd-int32) 12)
  (cl:setf (cl:ldb (cl:byte 1 29) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dd-int32)

(cl:export 'dd-string)

(cl:defgeneric dd-string (proto))
(cl:defmethod dd-string ((self test1proto))
  (base:utf8-octets-to-string (cl:slot-value self 'dd-string)))

(cl:export 'dd-string-octets)
(cl:defgeneric dd-string-octets (proto))
(cl:defmethod dd-string-octets ((self test1proto))
  (cl:slot-value self 'dd-string))

(cl:defgeneric (cl:setf dd-string) (new-value proto))
(cl:defmethod (cl:setf dd-string) (new-value (self test1proto))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'dd-string)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'dd-string) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 30) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf dd-string) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 30) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-dd-string (proto))
(cl:defmethod has-dd-string ((self test1proto))
  (cl:logbitp 30 (cl:slot-value self '%has-bits%)))
(cl:export 'has-dd-string)

(cl:defgeneric clear-dd-string (proto))
(cl:defmethod clear-dd-string ((self test1proto))
  (cl:setf (cl:slot-value self 'dd-string)
           (cl:make-array 6 :element-type '(cl:unsigned-byte 8)
            :initial-contents '(32 102 32 111 111 32)))
  (cl:setf (cl:ldb (cl:byte 1 30) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dd-string)

(cl:export 'dd-bool)


(cl:defmethod (cl:setf dd-bool) :after (x (self test1proto))
  (cl:setf (cl:ldb (cl:byte 1 31) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-dd-bool (proto))
(cl:defmethod has-dd-bool ((self test1proto))
  (cl:logbitp 31 (cl:slot-value self '%has-bits%)))
(cl:export 'has-dd-bool)

(cl:defgeneric clear-dd-bool (proto))
(cl:defmethod clear-dd-bool ((self test1proto))
  (cl:setf (cl:slot-value self 'dd-bool) cl:t)
  (cl:setf (cl:ldb (cl:byte 1 31) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dd-bool)


(cl:defmethod cl:print-object ((self test1proto-testgroup1) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "a: ~s " (cl:slot-value self 'a)))
    )
  (cl:values))

(cl:defmethod clear ((self test1proto-testgroup1))
  (cl:setf (cl:slot-value self 'a) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self test1proto-testgroup1))
  cl:t)

(cl:defmethod octet-size ((self test1proto-testgroup1))
  (cl:let ((size 0))
    ;; optional int32 a = 22;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'a))))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self test1proto-testgroup1) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int32 a = 22;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 176))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'a)))))
  index)



(cl:defmethod cl:print-object ((self test1proto-testgroup2) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "b: ~s " (cl:slot-value self 'b)))
    )
  (cl:values))

(cl:defmethod clear ((self test1proto-testgroup2))
  (cl:setf (cl:slot-value self 'b) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self test1proto-testgroup2))
  cl:t)

(cl:defmethod octet-size ((self test1proto-testgroup2))
  (cl:let ((size 0))
    ;; optional int32 b = 24;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'b))))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self test1proto-testgroup2) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int32 b = 24;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 192))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'b)))))
  index)



(cl:defmethod cl:print-object ((self test1proto) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "o-a: ~s " (cl:slot-value self 'o-a)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "o-b: ~s " (cl:slot-value self 'o-b)))
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-int32: ~s " (cl:slot-value self 'u-int32)))
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-int64: ~s " (cl:slot-value self 'u-int64)))
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-uint64: ~s " (cl:slot-value self 'u-uint64)))
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-fixed32: ~s " (cl:slot-value self 'u-fixed32)))
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-fixed64: ~s " (cl:slot-value self 'u-fixed64)))
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-bool: ~s " (cl:slot-value self 'u-bool)))
    (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-float: ~s " (cl:slot-value self 'u-float)))
    (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-double: ~s " (cl:slot-value self 'u-double)))
    (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-string: ~s " (cl:slot-value self 'u-string)))
    (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-vardata: ~s " (cl:slot-value self 'u-vardata)))
    (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
      (cl:format stream "u-msg: ~s " (cl:slot-value self 'u-msg)))
    (cl:format stream "r-int32: ~s " (cl:slot-value self 'r-int32))
    (cl:format stream "r-int64: ~s " (cl:slot-value self 'r-int64))
    (cl:format stream "r-uint64: ~s " (cl:slot-value self 'r-uint64))
    (cl:format stream "r-fixed32: ~s " (cl:slot-value self 'r-fixed32))
    (cl:format stream "r-fixed64: ~s " (cl:slot-value self 'r-fixed64))
    (cl:format stream "r-bool: ~s " (cl:slot-value self 'r-bool))
    (cl:format stream "r-float: ~s " (cl:slot-value self 'r-float))
    (cl:format stream "r-double: ~s " (cl:slot-value self 'r-double))
    (cl:format stream "r-string: ~s " (cl:slot-value self 'r-string))
    (cl:format stream "r-vardata: ~s " (cl:slot-value self 'r-vardata))
    (cl:format stream "r-msg: ~s " (cl:slot-value self 'r-msg))
    (cl:format stream "testgroup1: ~s " (cl:slot-value self 'testgroup1))
    (cl:format stream "testgroup2: ~s " (cl:slot-value self 'testgroup2))
    (cl:when (cl:logbitp 26 (cl:slot-value self '%has-bits%))
      (cl:format stream "d-int32: ~s " (cl:slot-value self 'd-int32)))
    (cl:when (cl:logbitp 27 (cl:slot-value self '%has-bits%))
      (cl:format stream "d-string: ~s " (cl:slot-value self 'd-string)))
    (cl:when (cl:logbitp 28 (cl:slot-value self '%has-bits%))
      (cl:format stream "d-bool: ~s " (cl:slot-value self 'd-bool)))
    (cl:when (cl:logbitp 29 (cl:slot-value self '%has-bits%))
      (cl:format stream "dd-int32: ~s " (cl:slot-value self 'dd-int32)))
    (cl:when (cl:logbitp 30 (cl:slot-value self '%has-bits%))
      (cl:format stream "dd-string: ~s " (cl:slot-value self 'dd-string)))
    (cl:when (cl:logbitp 31 (cl:slot-value self '%has-bits%))
      (cl:format stream "dd-bool: ~s " (cl:slot-value self 'dd-bool)))
    )
  (cl:values))

(cl:defmethod clear ((self test1proto))
  (cl:setf (cl:slot-value self 'o-a) 0)
  (cl:setf (cl:slot-value self 'o-b) 0)
  (cl:setf (cl:slot-value self 'u-int32) 0)
  (cl:setf (cl:slot-value self 'u-int64) 0)
  (cl:setf (cl:slot-value self 'u-uint64) 0)
  (cl:setf (cl:slot-value self 'u-fixed32) 0)
  (cl:setf (cl:slot-value self 'u-fixed64) 0)
  (cl:setf (cl:slot-value self 'u-bool) cl:nil)
  (cl:setf (cl:slot-value self 'u-float) 0s0)
  (cl:setf (cl:slot-value self 'u-double) 0d0)
  (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'u-string)
             (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
              :initial-contents '())))
  (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'u-vardata)
             (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
              :initial-contents '())))
  (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'u-msg) cl:nil))
  (cl:setf (cl:slot-value self 'd-int32) 12)
  (cl:when (cl:logbitp 27 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'd-string)
             (cl:make-array 3 :element-type '(cl:unsigned-byte 8)
              :initial-contents '(102 111 111))))
  (cl:setf (cl:slot-value self 'd-bool) cl:t)
  (cl:setf (cl:slot-value self 'dd-int32) 12)
  (cl:when (cl:logbitp 30 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'dd-string)
             (cl:make-array 6 :element-type '(cl:unsigned-byte 8)
              :initial-contents '(32 102 32 111 111 32))))
  (cl:setf (cl:slot-value self 'dd-bool) cl:t)
  (cl:setf (cl:slot-value self 'r-int32)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-int64)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-uint64)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-fixed32)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-fixed64)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-bool)
           (cl:make-array 0 :element-type 'cl:boolean
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-float)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-double)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-string)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-vardata)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'r-msg)
           (cl:make-array 0 :element-type 'test1msg
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'testgroup1)
           (cl:make-array 0 :element-type 'test1proto-testgroup1
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'testgroup2)
           (cl:make-array 0 :element-type 'test1proto-testgroup2
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self test1proto))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b00000000000000000000000000000001)
                  #b00000000000000000000000000000001)
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self test1proto))
  (cl:let ((size 0))
    ;; required int64 o_a = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int64-to-uint64 (cl:slot-value self 'o-a))))))
    ;; optional int64 o_b = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int64-to-uint64 (cl:slot-value self 'o-b))))))
    ;; optional int32 u_int32 = 3;
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'u-int32))))))
    ;; optional int64 u_int64 = 4;
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int64-to-uint64 (cl:slot-value self 'u-int64))))))
    ;; optional uint64 u_uint64 = 5;
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:slot-value self 'u-uint64)))))
    ;; optional fixed32 u_fixed32 = 6;
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; optional fixed64 u_fixed64 = 7;
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; optional bool u_bool = 8;
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional float u_float = 27;
    (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 4)))
    ;; optional double u_double = 28;
    (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 8)))
    ;; optional string u_string = 9;
    (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'u-string))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string u_vardata = 10;
    (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'u-vardata))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .Test1Msg u_msg = 11;
    (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
      (cl:let ((s (octet-size (cl:slot-value self 'u-msg))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; optional int32 d_int32 = 25 [default = 12];
    (cl:when (cl:logbitp 26 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'd-int32))))))
    ;; optional string d_string = 26 [default = "foo"];
    (cl:when (cl:logbitp 27 (cl:slot-value self '%has-bits%))
      (cl:incf size 2)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'd-string))))
        (cl:+ s (varint:length32 s)))))
    ;; optional bool d_bool = 31 [default = true];
    (cl:when (cl:logbitp 28 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; optional int32 dd_int32 = 32 [default = 12];
    (cl:when (cl:logbitp 29 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'dd-int32))))))
    ;; optional string dd_string = 33 [default = " f oo "];
    (cl:when (cl:logbitp 30 (cl:slot-value self '%has-bits%))
      (cl:incf size 2)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'dd-string))))
        (cl:+ s (varint:length32 s)))))
    ;; optional bool dd_bool = 34 [default = true];
    (cl:when (cl:logbitp 31 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; repeated int32 r_int32 = 12;
    (cl:let* ((x (cl:slot-value self 'r-int32))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (base:int32-to-uint64 (cl:aref (cl:slot-value self 'r-int32) i))))))
    ;; repeated int64 r_int64 = 13;
    (cl:let* ((x (cl:slot-value self 'r-int64))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (base:int64-to-uint64 (cl:aref (cl:slot-value self 'r-int64) i))))))
    ;; repeated uint64 r_uint64 = 14;
    (cl:let* ((x (cl:slot-value self 'r-uint64))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:aref (cl:slot-value self 'r-uint64) i)))))
    ;; repeated fixed32 r_fixed32 = 15;
    (cl:incf size (cl:* (cl:+ 1 4)
                     (cl:length (cl:slot-value self 'r-fixed32))))
    ;; repeated fixed64 r_fixed64 = 16;
    (cl:incf size (cl:* (cl:+ 2 8)
                     (cl:length (cl:slot-value self 'r-fixed64))))
    ;; repeated bool r_bool = 17;
    (cl:incf size (cl:* (cl:+ 2 1)
                     (cl:length (cl:slot-value self 'r-bool))))
    ;; repeated float r_float = 29;
    (cl:incf size (cl:* (cl:+ 2 4)
                     (cl:length (cl:slot-value self 'r-float))))
    ;; repeated double r_double = 30;
    (cl:incf size (cl:* (cl:+ 2 8)
                     (cl:length (cl:slot-value self 'r-double))))
    ;; repeated string r_string = 18;
    (cl:let* ((x (cl:slot-value self 'r-string))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (cl:let ((s (cl:length (cl:aref x i))))
           (cl:+ s (varint:length32 s))))))
    ;; repeated string r_vardata = 19;
    (cl:let* ((x (cl:slot-value self 'r-vardata))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (cl:let ((s (cl:length (cl:aref x i))))
           (cl:+ s (varint:length32 s))))))
    ;; repeated .Test1Msg r_msg = 20;
    (cl:let* ((v (cl:slot-value self 'r-msg))
              (length (cl:length v)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:let ((s (octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated group TestGroup1 = 21 {
    (cl:let* ((v (cl:slot-value self 'testgroup1))
              (length (cl:length v)))
      (cl:incf size (cl:* 4 length))
      (cl:dotimes (i length)
        (cl:incf size (octet-size (cl:aref v i)))))
    ;; repeated group TestGroup2 = 23 {
    (cl:let* ((v (cl:slot-value self 'testgroup2))
              (length (cl:length v)))
      (cl:incf size (cl:* 4 length))
      (cl:dotimes (i length)
        (cl:incf size (octet-size (cl:aref v i)))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self test1proto) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required int64 o_a = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:slot-value self 'o-a)))))
  ;; optional int64 o_b = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:slot-value self 'o-b)))))
  ;; optional int32 u_int32 = 3;
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'u-int32)))))
  ;; optional int64 u_int64 = 4;
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:slot-value self 'u-int64)))))
  ;; optional uint64 u_uint64 = 5;
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'u-uint64))))
  ;; optional fixed32 u_fixed32 = 6;
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 53))
    (cl:setf index (protocol:write-uint32-carefully buffer index limit (cl:slot-value self 'u-fixed32))))
  ;; optional fixed64 u_fixed64 = 7;
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 57))
    (cl:setf index (protocol:write-uint64-carefully buffer index limit (cl:slot-value self 'u-fixed64))))
  ;; optional bool u_bool = 8;
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 64))
    (cl:setf index (protocol:write-boolean-carefully buffer index limit (cl:slot-value self 'u-bool))))
  ;; optional string u_string = 9;
  (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
    (cl:setf index (protocol:write-octets-carefully buffer index limit (cl:slot-value self 'u-string))))
  ;; optional string u_vardata = 10;
  (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 82))
    (cl:setf index (protocol:write-octets-carefully buffer index limit (cl:slot-value self 'u-vardata))))
  ;; optional .Test1Msg u_msg = 11;
  (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 90))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'u-msg) '%cached-size%)))
    (cl:setf index (serialize (cl:slot-value self 'u-msg) buffer index limit)))
  ;; repeated int32 r_int32 = 12;
  (cl:let* ((v (cl:slot-value self 'r-int32))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 96))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:aref v i))))))
  ;; repeated int64 r_int64 = 13;
  (cl:let* ((v (cl:slot-value self 'r-int64))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 104))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:aref v i))))))
  ;; repeated uint64 r_uint64 = 14;
  (cl:let* ((v (cl:slot-value self 'r-uint64))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 112))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:aref v i)))))
  ;; repeated fixed32 r_fixed32 = 15;
  (cl:let* ((v (cl:slot-value self 'r-fixed32))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 125))
      (cl:setf index (protocol:write-uint32-carefully buffer index limit (cl:aref v i)))))
  ;; repeated fixed64 r_fixed64 = 16;
  (cl:let* ((v (cl:slot-value self 'r-fixed64))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 129))
      (cl:setf index (protocol:write-uint64-carefully buffer index limit (cl:aref v i)))))
  ;; repeated bool r_bool = 17;
  (cl:let* ((v (cl:slot-value self 'r-bool))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 136))
      (cl:setf index (protocol:write-boolean-carefully buffer index limit (cl:aref v i)))))
  ;; repeated string r_string = 18;
  (cl:let* ((v (cl:slot-value self 'r-string))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 146))
      (cl:setf index (protocol:write-octets-carefully buffer index limit (cl:aref v i)))))
  ;; repeated string r_vardata = 19;
  (cl:let* ((v (cl:slot-value self 'r-vardata))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 154))
      (cl:setf index (protocol:write-octets-carefully buffer index limit (cl:aref v i)))))
  ;; repeated .Test1Msg r_msg = 20;
  (cl:let* ((v (cl:slot-value self 'r-msg))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 162))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) '%cached-size%)))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))))
  ;; repeated group TestGroup1 = 21 {
  (cl:let* ((v (cl:slot-value self 'testgroup1))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 171))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 172))))
  ;; repeated group TestGroup2 = 23 {
  (cl:let* ((v (cl:slot-value self 'testgroup2))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 187))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 188))))
  ;; optional int32 d_int32 = 25 [default = 12];
  (cl:when (cl:logbitp 26 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 200))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'd-int32)))))
  ;; optional string d_string = 26 [default = "foo"];
  (cl:when (cl:logbitp 27 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 210))
    (cl:setf index (protocol:write-octets-carefully buffer index limit (cl:slot-value self 'd-string))))
  ;; optional float u_float = 27;
  (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 221))
    (cl:setf index (protocol:write-single-float-carefully buffer index limit (cl:slot-value self 'u-float))))
  ;; optional double u_double = 28;
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 225))
    (cl:setf index (protocol:write-double-float-carefully buffer index limit (cl:slot-value self 'u-double))))
  ;; repeated float r_float = 29;
  (cl:let* ((v (cl:slot-value self 'r-float))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 237))
      (cl:setf index (protocol:write-single-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated double r_double = 30;
  (cl:let* ((v (cl:slot-value self 'r-double))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 241))
      (cl:setf index (protocol:write-double-float-carefully buffer index limit (cl:aref v i)))))
  ;; optional bool d_bool = 31 [default = true];
  (cl:when (cl:logbitp 28 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 248))
    (cl:setf index (protocol:write-boolean-carefully buffer index limit (cl:slot-value self 'd-bool))))
  ;; optional int32 dd_int32 = 32 [default = 12];
  (cl:when (cl:logbitp 29 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 256))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'dd-int32)))))
  ;; optional string dd_string = 33 [default = " f oo "];
  (cl:when (cl:logbitp 30 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 266))
    (cl:setf index (protocol:write-octets-carefully buffer index limit (cl:slot-value self 'dd-string))))
  ;; optional bool dd_bool = 34 [default = true];
  (cl:when (cl:logbitp 31 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 272))
    (cl:setf index (protocol:write-boolean-carefully buffer index limit (cl:slot-value self 'dd-bool))))
  index)


