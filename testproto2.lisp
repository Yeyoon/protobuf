
;;;;    testproto2.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:protocol-buffer)

(cl:deftype testprotocol-four-nestedenum () '(cl:member 0))
(cl:export 'testprotocol-four-nestedenum)

(cl:defconstant +testprotocol-four-nestedenum-delete-me-to-crash-swig+ 0)
(cl:export '+testprotocol-four-nestedenum-delete-me-to-crash-swig+)

(cl:defconstant +minimum-testprotocol-four-nestedenum+ +testprotocol-four-nestedenum-delete-me-to-crash-swig+)
(cl:export '+minimum-testprotocol-four-nestedenum+)
(cl:defconstant +maximum-testprotocol-four-nestedenum+ +testprotocol-four-nestedenum-delete-me-to-crash-swig+)
(cl:export '+maximum-testprotocol-four-nestedenum+)

(cl:deftype testprotocol-docinfo () '(cl:member 0 1 2))
(cl:export 'testprotocol-docinfo)

(cl:defconstant +testprotocol-docinfo-enum-zero+ 0)
(cl:export '+testprotocol-docinfo-enum-zero+)
(cl:defconstant +testprotocol-docinfo-enum-one+ 1)
(cl:export '+testprotocol-docinfo-enum-one+)
(cl:defconstant +testprotocol-docinfo-enum-two-really-long-name+ 2)
(cl:export '+testprotocol-docinfo-enum-two-really-long-name+)

(cl:defconstant +minimum-testprotocol-docinfo+ +testprotocol-docinfo-enum-zero+)
(cl:export '+minimum-testprotocol-docinfo+)
(cl:defconstant +maximum-testprotocol-docinfo+ +testprotocol-docinfo-enum-two-really-long-name+)
(cl:export '+maximum-testprotocol-docinfo+)

(cl:deftype testprotocol-anotherenum () '(cl:member 0))
(cl:export 'testprotocol-anotherenum)

(cl:defconstant +testprotocol-anotherenum-enum-whatever+ 0)
(cl:export '+testprotocol-anotherenum-enum-whatever+)

(cl:defconstant +minimum-testprotocol-anotherenum+ +testprotocol-anotherenum-enum-whatever+)
(cl:export '+minimum-testprotocol-anotherenum+)
(cl:defconstant +maximum-testprotocol-anotherenum+ +testprotocol-anotherenum-enum-whatever+)
(cl:export '+maximum-testprotocol-anotherenum+)

(cl:defclass timeprotocol-g (protocol-buffer)
  (
  (v1
   :accessor v1
   :initform 0
   :type (cl:signed-byte 32))
  (v2
   :accessor v2
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'timeprotocol-g)

(cl:export 'v1)


(cl:defmethod (cl:setf v1) :after (x (self timeprotocol-g))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-v1 (proto))
(cl:defmethod has-v1 ((self timeprotocol-g))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-v1)

(cl:defgeneric clear-v1 (proto))
(cl:defmethod clear-v1 ((self timeprotocol-g))
  (cl:setf (cl:slot-value self 'v1) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-v1)

(cl:export 'v2)


(cl:defmethod (cl:setf v2) :after (x (self timeprotocol-g))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-v2 (proto))
(cl:defmethod has-v2 ((self timeprotocol-g))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-v2)

(cl:defgeneric clear-v2 (proto))
(cl:defmethod clear-v2 ((self timeprotocol-g))
  (cl:setf (cl:slot-value self 'v2) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-v2)



(cl:defclass timeprotocol (protocol-buffer)
  (
  (g
   :accessor g
   :initform (cl:make-array
              0
              :element-type 'timeprotocol-g
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector timeprotocol-g))
  (debug
   :accessor debug
   :initform (cl:make-array
              0
              :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:simple-array (cl:unsigned-byte 8) (cl:*))))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'timeprotocol)

(cl:export 'g)

(cl:defgeneric clear-g (proto))
(cl:defmethod clear-g ((self timeprotocol))
  (cl:setf (cl:slot-value self 'g)
           (cl:make-array 0 :element-type 'timeprotocol-g
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-g)

(cl:export 'debug)

(cl:defgeneric clear-debug (proto))
(cl:defmethod clear-debug ((self timeprotocol))
  (cl:setf (cl:slot-value self 'debug)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-debug)


(cl:defmethod cl:print-object ((self timeprotocol-g) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "v1: ~s " (cl:slot-value self 'v1)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "v2: ~s " (cl:slot-value self 'v2)))
    )
  (cl:values))

(cl:defmethod clear ((self timeprotocol-g))
  (cl:setf (cl:slot-value self 'v1) 0)
  (cl:setf (cl:slot-value self 'v2) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self timeprotocol-g))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b11)
                  #b11)
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self timeprotocol-g))
  (cl:let ((size 0))
    ;; required int32 V1 = 2;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'v1))))))
    ;; required int32 V2 = 3;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'v2))))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self timeprotocol-g) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required int32 V1 = 2;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'v1)))))
  ;; required int32 V2 = 3;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'v2)))))
  index)

(cl:defmethod merge-from-array ((self timeprotocol-g) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required int32 V1 = 2;
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'v1) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; required int32 V2 = 3;
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'v2) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self timeprotocol-g) (from timeprotocol-g))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'v1) (cl:slot-value from 'v1))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'v2) (cl:slot-value from 'v2))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self timeprotocol) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:format stream "g: ~s " (cl:slot-value self 'g))
    (cl:format stream "debug: ~s " (cl:slot-value self 'debug))
    )
  (cl:values))

(cl:defmethod clear ((self timeprotocol))
  (cl:setf (cl:slot-value self 'g)
           (cl:make-array 0 :element-type 'timeprotocol-g
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'debug)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self timeprotocol))
  (cl:let* ((x (cl:slot-value self 'g))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (is-initialized (cl:aref x i))
        (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self timeprotocol))
  (cl:let ((size 0))
    ;; repeated group G = 1 {
    (cl:let* ((v (cl:slot-value self 'g))
              (length (cl:length v)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size (octet-size (cl:aref v i)))))
    ;; repeated string Debug = 4;
    (cl:let* ((x (cl:slot-value self 'debug))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (cl:let ((s (cl:length (cl:aref x i))))
           (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self timeprotocol) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated group G = 1 {
  (cl:let* ((v (cl:slot-value self 'g))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 11))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 12))))
  ;; repeated string Debug = 4;
  (cl:let* ((v (cl:slot-value self 'debug))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:aref v i)))))
  index)

(cl:defmethod merge-from-array ((self timeprotocol) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated group G = 1 {
        ((11)
          (cl:let ((message (cl:make-instance 'timeprotocol-g)))
            (cl:setf index (merge-from-array message buffer index limit))
            (cl:vector-push-extend message (cl:slot-value self 'g)))
          ;; XXXX: wrong: tag size could be more than one byte
          ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 12)
          ;  (cl:error "bad group merge"))
          )
        ;; repeated string Debug = 4;
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:vector-push-extend value (cl:slot-value self 'debug))
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self timeprotocol) (from timeprotocol))
  (cl:let* ((v (cl:slot-value self 'g))
            (vf (cl:slot-value from 'g))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'debug))
            (vf (cl:slot-value from 'debug))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)


(cl:defclass testmessage (protocol-buffer)
  (
  (foo
   :accessor foo
   :initform 0
   :type (cl:signed-byte 32))
  (bar
   :accessor bar
   :initform 0
   :type (cl:signed-byte 32))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testmessage)

(cl:export 'foo)


(cl:defmethod (cl:setf foo) :after (x (self testmessage))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-foo (proto))
(cl:defmethod has-foo ((self testmessage))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-foo)

(cl:defgeneric clear-foo (proto))
(cl:defmethod clear-foo ((self testmessage))
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-foo)

(cl:export 'bar)


(cl:defmethod (cl:setf bar) :after (x (self testmessage))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-bar (proto))
(cl:defmethod has-bar ((self testmessage))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-bar)

(cl:defgeneric clear-bar (proto))
(cl:defmethod clear-bar ((self testmessage))
  (cl:setf (cl:slot-value self 'bar) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-bar)


(cl:defmethod cl:print-object ((self testmessage) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "foo: ~s " (cl:slot-value self 'foo)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "bar: ~s " (cl:slot-value self 'bar)))
    )
  (cl:values))

(cl:defmethod clear ((self testmessage))
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf (cl:slot-value self 'bar) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testmessage))
  cl:t)

(cl:defmethod octet-size ((self testmessage))
  (cl:let ((size 0))
    ;; optional int32 foo = 1;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'foo))))))
    ;; optional int32 bar = 2;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'bar))))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testmessage) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int32 foo = 1;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'foo)))))
  ;; optional int32 bar = 2;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:slot-value self 'bar)))))
  index)

(cl:defmethod merge-from-array ((self testmessage) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional int32 foo = 1;
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'foo) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int32 bar = 2;
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'bar) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testmessage) (from testmessage))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'foo) (cl:slot-value from 'foo))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'bar) (cl:slot-value from 'bar))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass testprotocol-four-seven-twelve (protocol-buffer)
  (
  (thirteen
   :accessor thirteen
   :initform cl:nil
   :type cl:boolean)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol-four-seven-twelve)

(cl:export 'thirteen)


(cl:defmethod (cl:setf thirteen) :after (x (self testprotocol-four-seven-twelve))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-thirteen (proto))
(cl:defmethod has-thirteen ((self testprotocol-four-seven-twelve))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-thirteen)

(cl:defgeneric clear-thirteen (proto))
(cl:defmethod clear-thirteen ((self testprotocol-four-seven-twelve))
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-thirteen)



(cl:defclass testprotocol-four-seven (protocol-buffer)
  (
  (four
   :accessor four
   :initform cl:nil
   :type cl:boolean)
  (twelve
   :writer (cl:setf twelve)
   :initform cl:nil
   :type (cl:or cl:null testprotocol-four-seven-twelve))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol-four-seven)

(cl:export 'four)


(cl:defmethod (cl:setf four) :after (x (self testprotocol-four-seven))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-four (proto))
(cl:defmethod has-four ((self testprotocol-four-seven))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-four)

(cl:defgeneric clear-four (proto))
(cl:defmethod clear-four ((self testprotocol-four-seven))
  (cl:setf (cl:slot-value self 'four) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-four)

(cl:export 'twelve)

(cl:defgeneric twelve (proto))
(cl:defmethod twelve ((self testprotocol-four-seven))
  (cl:let ((result (cl:slot-value self 'twelve)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'testprotocol-four-seven-twelve))
      (cl:setf (cl:slot-value self 'twelve) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf twelve) :after (x (self testprotocol-four-seven))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-twelve (proto))
(cl:defmethod has-twelve ((self testprotocol-four-seven))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-twelve)

(cl:defgeneric clear-twelve (proto))
(cl:defmethod clear-twelve ((self testprotocol-four-seven))
  (cl:setf (cl:slot-value self 'twelve) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-twelve)



(cl:defclass testprotocol-four (protocol-buffer)
  (
  (five
   :accessor five
   :initform 0
   :type (cl:signed-byte 64))
  (six
   :accessor six
   :initform 0
   :type (cl:unsigned-byte 64))
  (tp
   :writer (cl:setf tp)
   :initform cl:nil
   :type (cl:or cl:null timeprotocol))
  (seven
   :accessor seven
   :initform (cl:make-array
              0
              :element-type 'testprotocol-four-seven
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector testprotocol-four-seven))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 4))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol-four)

(cl:export 'five)


(cl:defmethod (cl:setf five) :after (x (self testprotocol-four))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-five (proto))
(cl:defmethod has-five ((self testprotocol-four))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-five)

(cl:defgeneric clear-five (proto))
(cl:defmethod clear-five ((self testprotocol-four))
  (cl:setf (cl:slot-value self 'five) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-five)

(cl:export 'six)


(cl:defmethod (cl:setf six) :after (x (self testprotocol-four))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-six (proto))
(cl:defmethod has-six ((self testprotocol-four))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-six)

(cl:defgeneric clear-six (proto))
(cl:defmethod clear-six ((self testprotocol-four))
  (cl:setf (cl:slot-value self 'six) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-six)

(cl:export 'tp)

(cl:defgeneric tp (proto))
(cl:defmethod tp ((self testprotocol-four))
  (cl:let ((result (cl:slot-value self 'tp)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'timeprotocol))
      (cl:setf (cl:slot-value self 'tp) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf tp) :after (x (self testprotocol-four))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-tp (proto))
(cl:defmethod has-tp ((self testprotocol-four))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-tp)

(cl:defgeneric clear-tp (proto))
(cl:defmethod clear-tp ((self testprotocol-four))
  (cl:setf (cl:slot-value self 'tp) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-tp)

(cl:export 'seven)

(cl:defgeneric clear-seven (proto))
(cl:defmethod clear-seven ((self testprotocol-four))
  (cl:setf (cl:slot-value self 'seven)
           (cl:make-array 0 :element-type 'testprotocol-four-seven
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-seven)



(cl:defclass testprotocol-seven (protocol-buffer)
  (
  (eight
   :accessor eight
   :initform 0
   :type (cl:signed-byte 64))
  (nine
   :accessor nine
   :initform cl:nil
   :type cl:boolean)
  (ten
   :accessor ten
   :initform cl:t
   :type cl:boolean)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol-seven)

(cl:export 'eight)


(cl:defmethod (cl:setf eight) :after (x (self testprotocol-seven))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-eight (proto))
(cl:defmethod has-eight ((self testprotocol-seven))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-eight)

(cl:defgeneric clear-eight (proto))
(cl:defmethod clear-eight ((self testprotocol-seven))
  (cl:setf (cl:slot-value self 'eight) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-eight)

(cl:export 'nine)


(cl:defmethod (cl:setf nine) :after (x (self testprotocol-seven))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-nine (proto))
(cl:defmethod has-nine ((self testprotocol-seven))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-nine)

(cl:defgeneric clear-nine (proto))
(cl:defmethod clear-nine ((self testprotocol-seven))
  (cl:setf (cl:slot-value self 'nine) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-nine)

(cl:export 'ten)


(cl:defmethod (cl:setf ten) :after (x (self testprotocol-seven))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-ten (proto))
(cl:defmethod has-ten ((self testprotocol-seven))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-ten)

(cl:defgeneric clear-ten (proto))
(cl:defmethod clear-ten ((self testprotocol-seven))
  (cl:setf (cl:slot-value self 'ten) cl:t)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-ten)



(cl:defclass testprotocol-thirteen (protocol-buffer)
  (
  (fourteen
   :accessor fourteen
   :initform 0
   :type testprotocol-anotherenum)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol-thirteen)

(cl:export 'fourteen)


(cl:defmethod (cl:setf fourteen) :after (x (self testprotocol-thirteen))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-fourteen (proto))
(cl:defmethod has-fourteen ((self testprotocol-thirteen))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-fourteen)

(cl:defgeneric clear-fourteen (proto))
(cl:defmethod clear-fourteen ((self testprotocol-thirteen))
  (cl:setf (cl:slot-value self 'fourteen) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-fourteen)



(cl:defclass testprotocol-test6 (protocol-buffer)
  (
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol-test6)



(cl:defclass testprotocol (protocol-buffer)
  (
  (zero
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '())
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (one
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '())
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (two
   :accessor two
   :initform 19
   :type (cl:signed-byte 64))
  (four
   :accessor four
   :initform (cl:make-array
              0
              :element-type 'testprotocol-four
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector testprotocol-four))
  (seven
   :writer (cl:setf seven)
   :initform cl:nil
   :type (cl:or cl:null testprotocol-seven))
  (tp2
   :accessor tp2
   :initform (cl:make-array
              0
              :element-type 'timeprotocol
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector timeprotocol))
  (test1
   :accessor test1
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 64)))
  (test2
   :accessor test2
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 32)))
  (test3
   :accessor test3
   :initform (cl:make-array
              0
              :element-type 'cl:single-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:single-float))
  (test4
   :accessor test4
   :initform (cl:make-array
              0
              :element-type 'cl:double-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:double-float))
  (test5
   :accessor test5
   :initform (cl:make-array
              0
              :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:simple-array (cl:unsigned-byte 8) (cl:*))))
  (fixedvalue
   :accessor fixedvalue
   :initform 0
   :type (cl:unsigned-byte 64))
  (fixedvalue2
   :accessor fixedvalue2
   :initform 0
   :type (cl:unsigned-byte 32))
  (optstring
   :initform (cl:make-array
              3
              :element-type '(cl:unsigned-byte 8)
              :initial-contents '(111 112 116))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (eleven
   :writer (cl:setf eleven)
   :initform cl:nil
   :type (cl:or cl:null testmessage))
  (twelve
   :accessor twelve
   :initform 0
   :type testprotocol-anotherenum)
  (thirteen
   :writer (cl:setf thirteen)
   :initform cl:nil
   :type (cl:or cl:null testprotocol-thirteen))
  (test6
   :accessor test6
   :initform (cl:make-array
              0
              :element-type 'testprotocol-test6
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector testprotocol-test6))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 18))
  (%cached-size%
   :accessor %cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'testprotocol)

(cl:export 'zero)

(cl:defgeneric zero (proto))
(cl:defmethod zero ((self testprotocol))
  (base:utf8-octets-to-string (cl:slot-value self 'zero)))

(cl:export 'zero-octets)
(cl:defgeneric zero-octets (proto))
(cl:defmethod zero-octets ((self testprotocol))
  (cl:slot-value self 'zero))

(cl:defgeneric (cl:setf zero) (new-value proto))
(cl:defmethod (cl:setf zero) (new-value (self testprotocol))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'zero)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'zero) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf zero) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-zero (proto))
(cl:defmethod has-zero ((self testprotocol))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-zero)

(cl:defgeneric clear-zero (proto))
(cl:defmethod clear-zero ((self testprotocol))
  (cl:setf (cl:slot-value self 'zero)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
            :initial-contents '()))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-zero)

(cl:export 'one)

(cl:defgeneric one (proto))
(cl:defmethod one ((self testprotocol))
  (base:utf8-octets-to-string (cl:slot-value self 'one)))

(cl:export 'one-octets)
(cl:defgeneric one-octets (proto))
(cl:defmethod one-octets ((self testprotocol))
  (cl:slot-value self 'one))

(cl:defgeneric (cl:setf one) (new-value proto))
(cl:defmethod (cl:setf one) (new-value (self testprotocol))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'one)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'one) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf one) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-one (proto))
(cl:defmethod has-one ((self testprotocol))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-one)

(cl:defgeneric clear-one (proto))
(cl:defmethod clear-one ((self testprotocol))
  (cl:setf (cl:slot-value self 'one)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
            :initial-contents '()))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-one)

(cl:export 'two)


(cl:defmethod (cl:setf two) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-two (proto))
(cl:defmethod has-two ((self testprotocol))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-two)

(cl:defgeneric clear-two (proto))
(cl:defmethod clear-two ((self testprotocol))
  (cl:setf (cl:slot-value self 'two) 19)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-two)

(cl:export 'four)

(cl:defgeneric clear-four (proto))
(cl:defmethod clear-four ((self testprotocol))
  (cl:setf (cl:slot-value self 'four)
           (cl:make-array 0 :element-type 'testprotocol-four
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-four)

(cl:export 'seven)

(cl:defgeneric seven (proto))
(cl:defmethod seven ((self testprotocol))
  (cl:let ((result (cl:slot-value self 'seven)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'testprotocol-seven))
      (cl:setf (cl:slot-value self 'seven) result))
      (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf seven) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-seven (proto))
(cl:defmethod has-seven ((self testprotocol))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-seven)

(cl:defgeneric clear-seven (proto))
(cl:defmethod clear-seven ((self testprotocol))
  (cl:setf (cl:slot-value self 'seven) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-seven)

(cl:export 'tp2)

(cl:defgeneric clear-tp2 (proto))
(cl:defmethod clear-tp2 ((self testprotocol))
  (cl:setf (cl:slot-value self 'tp2)
           (cl:make-array 0 :element-type 'timeprotocol
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-tp2)

(cl:export 'test1)

(cl:defgeneric clear-test1 (proto))
(cl:defmethod clear-test1 ((self testprotocol))
  (cl:setf (cl:slot-value self 'test1)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-test1)

(cl:export 'test2)

(cl:defgeneric clear-test2 (proto))
(cl:defmethod clear-test2 ((self testprotocol))
  (cl:setf (cl:slot-value self 'test2)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-test2)

(cl:export 'test3)

(cl:defgeneric clear-test3 (proto))
(cl:defmethod clear-test3 ((self testprotocol))
  (cl:setf (cl:slot-value self 'test3)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-test3)

(cl:export 'test4)

(cl:defgeneric clear-test4 (proto))
(cl:defmethod clear-test4 ((self testprotocol))
  (cl:setf (cl:slot-value self 'test4)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-test4)

(cl:export 'test5)

(cl:defgeneric clear-test5 (proto))
(cl:defmethod clear-test5 ((self testprotocol))
  (cl:setf (cl:slot-value self 'test5)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-test5)

(cl:export 'fixedvalue)


(cl:defmethod (cl:setf fixedvalue) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-fixedvalue (proto))
(cl:defmethod has-fixedvalue ((self testprotocol))
  (cl:logbitp 11 (cl:slot-value self '%has-bits%)))
(cl:export 'has-fixedvalue)

(cl:defgeneric clear-fixedvalue (proto))
(cl:defmethod clear-fixedvalue ((self testprotocol))
  (cl:setf (cl:slot-value self 'fixedvalue) 0)
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-fixedvalue)

(cl:export 'fixedvalue2)


(cl:defmethod (cl:setf fixedvalue2) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-fixedvalue2 (proto))
(cl:defmethod has-fixedvalue2 ((self testprotocol))
  (cl:logbitp 12 (cl:slot-value self '%has-bits%)))
(cl:export 'has-fixedvalue2)

(cl:defgeneric clear-fixedvalue2 (proto))
(cl:defmethod clear-fixedvalue2 ((self testprotocol))
  (cl:setf (cl:slot-value self 'fixedvalue2) 0)
  (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-fixedvalue2)

(cl:export 'optstring)

(cl:defgeneric optstring (proto))
(cl:defmethod optstring ((self testprotocol))
  (base:utf8-octets-to-string (cl:slot-value self 'optstring)))

(cl:export 'optstring-octets)
(cl:defgeneric optstring-octets (proto))
(cl:defmethod optstring-octets ((self testprotocol))
  (cl:slot-value self 'optstring))

(cl:defgeneric (cl:setf optstring) (new-value proto))
(cl:defmethod (cl:setf optstring) (new-value (self testprotocol))
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'optstring)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'optstring) new-value)))
  (cl:setf (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 1)
  new-value)

(cl:defmethod (cl:setf optstring) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-optstring (proto))
(cl:defmethod has-optstring ((self testprotocol))
  (cl:logbitp 13 (cl:slot-value self '%has-bits%)))
(cl:export 'has-optstring)

(cl:defgeneric clear-optstring (proto))
(cl:defmethod clear-optstring ((self testprotocol))
  (cl:setf (cl:slot-value self 'optstring)
           (cl:make-array 3 :element-type '(cl:unsigned-byte 8)
            :initial-contents '(111 112 116)))
  (cl:setf (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-optstring)

(cl:export 'eleven)

(cl:defgeneric eleven (proto))
(cl:defmethod eleven ((self testprotocol))
  (cl:let ((result (cl:slot-value self 'eleven)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'testmessage))
      (cl:setf (cl:slot-value self 'eleven) result))
      (cl:setf (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf eleven) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-eleven (proto))
(cl:defmethod has-eleven ((self testprotocol))
  (cl:logbitp 14 (cl:slot-value self '%has-bits%)))
(cl:export 'has-eleven)

(cl:defgeneric clear-eleven (proto))
(cl:defmethod clear-eleven ((self testprotocol))
  (cl:setf (cl:slot-value self 'eleven) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-eleven)

(cl:export 'twelve)


(cl:defmethod (cl:setf twelve) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-twelve (proto))
(cl:defmethod has-twelve ((self testprotocol))
  (cl:logbitp 15 (cl:slot-value self '%has-bits%)))
(cl:export 'has-twelve)

(cl:defgeneric clear-twelve (proto))
(cl:defmethod clear-twelve ((self testprotocol))
  (cl:setf (cl:slot-value self 'twelve) 0)
  (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-twelve)

(cl:export 'thirteen)

(cl:defgeneric thirteen (proto))
(cl:defmethod thirteen ((self testprotocol))
  (cl:let ((result (cl:slot-value self 'thirteen)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'testprotocol-thirteen))
      (cl:setf (cl:slot-value self 'thirteen) result))
      (cl:setf (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf thirteen) :after (x (self testprotocol))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 1))

(cl:defgeneric has-thirteen (proto))
(cl:defmethod has-thirteen ((self testprotocol))
  (cl:logbitp 16 (cl:slot-value self '%has-bits%)))
(cl:export 'has-thirteen)

(cl:defgeneric clear-thirteen (proto))
(cl:defmethod clear-thirteen ((self testprotocol))
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-thirteen)

(cl:export 'test6)

(cl:defgeneric clear-test6 (proto))
(cl:defmethod clear-test6 ((self testprotocol))
  (cl:setf (cl:slot-value self 'test6)
           (cl:make-array 0 :element-type 'testprotocol-test6
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-test6)


(cl:defmethod cl:print-object ((self testprotocol-four-seven-twelve) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "thirteen: ~s " (cl:slot-value self 'thirteen)))
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol-four-seven-twelve))
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol-four-seven-twelve))
  cl:t)

(cl:defmethod octet-size ((self testprotocol-four-seven-twelve))
  (cl:let ((size 0))
    ;; optional bool Thirteen = 68;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol-four-seven-twelve) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional bool Thirteen = 68;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 544))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'thirteen))))
  index)

(cl:defmethod merge-from-array ((self testprotocol-four-seven-twelve) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional bool Thirteen = 68;
        ((544)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'thirteen) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol-four-seven-twelve) (from testprotocol-four-seven-twelve))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'thirteen) (cl:slot-value from 'thirteen))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self testprotocol-four-seven) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "four: ~s " (cl:slot-value self 'four)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "twelve: ~s " (cl:slot-value self 'twelve)))
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol-four-seven))
  (cl:setf (cl:slot-value self 'four) cl:nil)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'twelve) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol-four-seven))
  cl:t)

(cl:defmethod octet-size ((self testprotocol-four-seven))
  (cl:let ((size 0))
    ;; optional bool Four = 66 [default = false];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; optional group Twelve = 67 {
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size (cl:+ 4 (octet-size (cl:slot-value self 'twelve)))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol-four-seven) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional bool Four = 66 [default = false];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 528))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'four))))
  ;; optional group Twelve = 67 {
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 539))
    (cl:setf index (serialize (cl:slot-value self 'twelve) buffer index limit))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 540)))
  index)

(cl:defmethod merge-from-array ((self testprotocol-four-seven) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; optional bool Four = 66 [default = false];
        ((528)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'four) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional group Twelve = 67 {
        ((539)
          (cl:let ((message (cl:slot-value self 'twelve)))
            (cl:when (cl:null message)
              (cl:setf message (cl:make-instance 'testprotocol-four-seven-twelve))
              (cl:setf (cl:slot-value self 'twelve) message)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
            (cl:setf index (merge-from-array message buffer index limit))
            ;; XXXX: wrong: tag size could be more than one byte
            ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 540)
            ;  (cl:error "bad group merge"))
            ))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol-four-seven) (from testprotocol-four-seven))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'four) (cl:slot-value from 'four))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'twelve)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'testprotocol-four-seven-twelve))
        (cl:setf (cl:slot-value self 'twelve) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (merge-from-message message (cl:slot-value from 'twelve))))
)



(cl:defmethod cl:print-object ((self testprotocol-four) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "five: ~s " (cl:slot-value self 'five)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "six: ~s " (cl:slot-value self 'six)))
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:format stream "tp: ~s " (cl:slot-value self 'tp)))
    (cl:format stream "seven: ~s " (cl:slot-value self 'seven))
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol-four))
  (cl:setf (cl:slot-value self 'five) 0)
  (cl:setf (cl:slot-value self 'six) 0)
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'tp) cl:nil))
  (cl:setf (cl:slot-value self 'seven)
           (cl:make-array 0 :element-type 'testprotocol-four-seven
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol-four))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b0011)
                  #b0011)
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:unless (is-initialized (cl:slot-value self 'tp))
      (cl:return-from is-initialized cl:nil)))
  cl:t)

(cl:defmethod octet-size ((self testprotocol-four))
  (cl:let ((size 0))
    ;; required int64 Five = 5;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int64-to-uint64 (cl:slot-value self 'five))))))
    ;; required uint64 Six = 64;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 (varint:length64 (cl:slot-value self 'six)))))
    ;; optional .TimeProtocol TP = 112;
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (octet-size (cl:slot-value self 'tp))))
        (cl:incf size (cl:+ 2 s (varint:length32 s)))))
    ;; repeated group Seven = 65 {
    (cl:let* ((v (cl:slot-value self 'seven))
              (length (cl:length v)))
      (cl:incf size (cl:* 4 length))
      (cl:dotimes (i length)
        (cl:incf size (octet-size (cl:aref v i)))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol-four) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required int64 Five = 5;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:slot-value self 'five)))))
  ;; required uint64 Six = 64;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 512))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:slot-value self 'six))))
  ;; repeated group Seven = 65 {
  (cl:let* ((v (cl:slot-value self 'seven))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 523))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 524))))
  ;; optional .TimeProtocol TP = 112;
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 898))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'tp) '%cached-size%)))
    (cl:setf index (serialize (cl:slot-value self 'tp) buffer index limit)))
  index)

(cl:defmethod merge-from-array ((self testprotocol-four) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required int64 Five = 5;
        ((40)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'five) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; required uint64 Six = 64;
        ((512)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'six) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated group Seven = 65 {
        ((523)
          (cl:let ((message (cl:make-instance 'testprotocol-four-seven)))
            (cl:setf index (merge-from-array message buffer index limit))
            (cl:vector-push-extend message (cl:slot-value self 'seven)))
          ;; XXXX: wrong: tag size could be more than one byte
          ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 524)
          ;  (cl:error "bad group merge"))
          )
        ;; optional .TimeProtocol TP = 112;
        ((898)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'tp)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'timeprotocol))
                (cl:setf (cl:slot-value self 'tp) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol-four) (from testprotocol-four))
  (cl:let* ((v (cl:slot-value self 'seven))
            (vf (cl:slot-value from 'seven))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'five) (cl:slot-value from 'five))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'six) (cl:slot-value from 'six))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'tp)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'timeprotocol))
        (cl:setf (cl:slot-value self 'tp) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (merge-from-message message (cl:slot-value from 'tp))))
)



(cl:defmethod cl:print-object ((self testprotocol-seven) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "eight: ~s " (cl:slot-value self 'eight)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "nine: ~s " (cl:slot-value self 'nine)))
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:format stream "ten: ~s " (cl:slot-value self 'ten)))
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol-seven))
  (cl:setf (cl:slot-value self 'eight) 0)
  (cl:setf (cl:slot-value self 'nine) cl:nil)
  (cl:setf (cl:slot-value self 'ten) cl:t)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol-seven))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b011)
                  #b011)
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self testprotocol-seven))
  (cl:let ((size 0))
    ;; required int64 Eight = 8;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int64-to-uint64 (cl:slot-value self 'eight))))))
    ;; required bool Nine = 9;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional bool Ten = 10 [default = true];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol-seven) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required int64 Eight = 8;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 64))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:slot-value self 'eight)))))
  ;; required bool Nine = 9;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 72))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'nine))))
  ;; optional bool Ten = 10 [default = true];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 80))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'ten))))
  index)

(cl:defmethod merge-from-array ((self testprotocol-seven) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required int64 Eight = 8;
        ((64)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'eight) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; required bool Nine = 9;
        ((72)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'nine) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional bool Ten = 10 [default = true];
        ((80)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'ten) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol-seven) (from testprotocol-seven))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'eight) (cl:slot-value from 'eight))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'nine) (cl:slot-value from 'nine))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'ten) (cl:slot-value from 'ten))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self testprotocol-thirteen) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "fourteen: ~s " (cl:slot-value self 'fourteen)))
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol-thirteen))
  (cl:setf (cl:slot-value self 'fourteen) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol-thirteen))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b1)
                  #b1)
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self testprotocol-thirteen))
  (cl:let ((size 0))
    ;; required .TestProtocol.AnotherEnum Fourteen = 315;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 2)
      (cl:incf size (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'fourteen)))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol-thirteen) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required .TestProtocol.AnotherEnum Fourteen = 315;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2520))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (base:int32-to-uint64 (cl:slot-value self 'fourteen)))))
  index)

(cl:defmethod merge-from-array ((self testprotocol-thirteen) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required .TestProtocol.AnotherEnum Fourteen = 315;
        ((2520)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'fourteen) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol-thirteen) (from testprotocol-thirteen))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'fourteen) (cl:slot-value from 'fourteen))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self testprotocol-test6) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol-test6))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol-test6))
  cl:t)

(cl:defmethod octet-size ((self testprotocol-test6))
  (cl:let ((size 0))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol-test6) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  index)

(cl:defmethod merge-from-array ((self testprotocol-test6) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol-test6) (from testprotocol-test6))
)



(cl:defmethod cl:print-object ((self testprotocol) stream)
  (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:format stream "zero: ~s " (cl:slot-value self 'zero)))
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:format stream "one: ~s " (cl:slot-value self 'one)))
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:format stream "two: ~s " (cl:slot-value self 'two)))
    (cl:format stream "four: ~s " (cl:slot-value self 'four))
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:format stream "seven: ~s " (cl:slot-value self 'seven)))
    (cl:format stream "tp2: ~s " (cl:slot-value self 'tp2))
    (cl:format stream "test1: ~s " (cl:slot-value self 'test1))
    (cl:format stream "test2: ~s " (cl:slot-value self 'test2))
    (cl:format stream "test3: ~s " (cl:slot-value self 'test3))
    (cl:format stream "test4: ~s " (cl:slot-value self 'test4))
    (cl:format stream "test5: ~s " (cl:slot-value self 'test5))
    (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
      (cl:format stream "fixedvalue: ~s " (cl:slot-value self 'fixedvalue)))
    (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
      (cl:format stream "fixedvalue2: ~s " (cl:slot-value self 'fixedvalue2)))
    (cl:when (cl:logbitp 13 (cl:slot-value self '%has-bits%))
      (cl:format stream "optstring: ~s " (cl:slot-value self 'optstring)))
    (cl:when (cl:logbitp 14 (cl:slot-value self '%has-bits%))
      (cl:format stream "eleven: ~s " (cl:slot-value self 'eleven)))
    (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
      (cl:format stream "twelve: ~s " (cl:slot-value self 'twelve)))
    (cl:when (cl:logbitp 16 (cl:slot-value self '%has-bits%))
      (cl:format stream "thirteen: ~s " (cl:slot-value self 'thirteen)))
    (cl:format stream "test6: ~s " (cl:slot-value self 'test6))
    )
  (cl:values))

(cl:defmethod clear ((self testprotocol))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'zero)
             (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
              :initial-contents '())))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'one)
             (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
              :initial-contents '())))
  (cl:setf (cl:slot-value self 'two) 19)
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'seven) cl:nil))
  (cl:setf (cl:slot-value self 'fixedvalue) 0)
  (cl:setf (cl:slot-value self 'fixedvalue2) 0)
  (cl:when (cl:logbitp 13 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'optstring)
             (cl:make-array 3 :element-type '(cl:unsigned-byte 8)
              :initial-contents '(111 112 116))))
  (cl:when (cl:logbitp 14 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'eleven) cl:nil))
  (cl:setf (cl:slot-value self 'twelve) 0)
  (cl:when (cl:logbitp 16 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'thirteen) cl:nil))
  (cl:setf (cl:slot-value self 'four)
           (cl:make-array 0 :element-type 'testprotocol-four
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'tp2)
           (cl:make-array 0 :element-type 'timeprotocol
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test1)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test2)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test3)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test4)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test5)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test6)
           (cl:make-array 0 :element-type 'testprotocol-test6
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod is-initialized ((self testprotocol))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b000001100000000011)
                  #b000001100000000011)
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'four))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (is-initialized (cl:aref x i))
        (cl:return-from is-initialized cl:nil))))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:unless (is-initialized (cl:slot-value self 'seven))
      (cl:return-from is-initialized cl:nil)))
  (cl:let* ((x (cl:slot-value self 'tp2))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (is-initialized (cl:aref x i))
        (cl:return-from is-initialized cl:nil))))
  (cl:when (cl:logbitp 16 (cl:slot-value self '%has-bits%))
    (cl:unless (is-initialized (cl:slot-value self 'thirteen))
      (cl:return-from is-initialized cl:nil)))
  cl:t)

(cl:defmethod octet-size ((self testprotocol))
  (cl:let ((size 0))
    ;; required string Zero = 63;
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 2)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'zero))))
        (cl:+ s (varint:length32 s)))))
    ;; required string One = 1;
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'one))))
        (cl:+ s (varint:length32 s)))))
    ;; optional int64 Two = 2 [default = 19];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (base:int64-to-uint64 (cl:slot-value self 'two))))))
    ;; optional group Seven = 7 {
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size (cl:+ 2 (octet-size (cl:slot-value self 'seven)))))
    ;; required fixed64 FixedValue = 310;
    (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 8)))
    ;; required fixed32 FixedValue2 = 311;
    (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 4)))
    ;; optional string OptString = 299 [default = "opt"];
    (cl:when (cl:logbitp 13 (cl:slot-value self '%has-bits%))
      (cl:incf size 2)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'optstring))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .TestMessage Eleven = 312;
    (cl:when (cl:logbitp 14 (cl:slot-value self '%has-bits%))
      (cl:let ((s (octet-size (cl:slot-value self 'eleven))))
        (cl:incf size (cl:+ 2 s (varint:length32 s)))))
    ;; optional .TestProtocol.AnotherEnum Twelve = 313;
    (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
      (cl:incf size 2)
      (cl:incf size (varint:length64 (base:int32-to-uint64 (cl:slot-value self 'twelve)))))
    ;; optional group Thirteen = 314 {
    (cl:when (cl:logbitp 16 (cl:slot-value self '%has-bits%))
      (cl:incf size (cl:+ 4 (octet-size (cl:slot-value self 'thirteen)))))
    ;; repeated group Four = 4 {
    (cl:let* ((v (cl:slot-value self 'four))
              (length (cl:length v)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size (octet-size (cl:aref v i)))))
    ;; repeated .TimeProtocol TP2 = 113;
    (cl:let* ((v (cl:slot-value self 'tp2))
              (length (cl:length v)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:let ((s (octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated int64 Test1 = 301;
    (cl:let* ((x (cl:slot-value self 'test1))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (base:int64-to-uint64 (cl:aref (cl:slot-value self 'test1) i))))))
    ;; repeated int32 Test2 = 302;
    (cl:let* ((x (cl:slot-value self 'test2))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (base:int32-to-uint64 (cl:aref (cl:slot-value self 'test2) i))))))
    ;; repeated float Test3 = 303;
    (cl:incf size (cl:* (cl:+ 2 4)
                     (cl:length (cl:slot-value self 'test3))))
    ;; repeated double Test4 = 304;
    (cl:incf size (cl:* (cl:+ 2 8)
                     (cl:length (cl:slot-value self 'test4))))
    ;; repeated string Test5 = 305;
    (cl:let* ((x (cl:slot-value self 'test5))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (cl:let ((s (cl:length (cl:aref x i))))
           (cl:+ s (varint:length32 s))))))
    ;; repeated group Test6 = 306 {
    (cl:let* ((v (cl:slot-value self 'test6))
              (length (cl:length v)))
      (cl:incf size (cl:* 4 length))
      (cl:dotimes (i length)
        (cl:incf size (octet-size (cl:aref v i)))))
    (cl:setf (cl:slot-value self '%cached-size%) size)
    size))

(cl:defmethod serialize ((self testprotocol) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required string One = 1;
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'one))))
  ;; optional int64 Two = 2 [default = 19];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:slot-value self 'two)))))
  ;; repeated group Four = 4 {
  (cl:let* ((v (cl:slot-value self 'four))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 35))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 36))))
  ;; optional group Seven = 7 {
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 59))
    (cl:setf index (serialize (cl:slot-value self 'seven) buffer index limit))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 60)))
  ;; required string Zero = 63;
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 506))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'zero))))
  ;; repeated .TimeProtocol TP2 = 113;
  (cl:let* ((v (cl:slot-value self 'tp2))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 906))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) '%cached-size%)))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))))
  ;; optional string OptString = 299 [default = "opt"];
  (cl:when (cl:logbitp 13 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2394))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'optstring))))
  ;; repeated int64 Test1 = 301;
  (cl:let* ((v (cl:slot-value self 'test1))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 2408))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int64-to-uint64 (cl:aref v i))))))
  ;; repeated int32 Test2 = 302;
  (cl:let* ((v (cl:slot-value self 'test2))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 2416))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (base:int32-to-uint64 (cl:aref v i))))))
  ;; repeated float Test3 = 303;
  (cl:let* ((v (cl:slot-value self 'test3))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 2429))
      (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated double Test4 = 304;
  (cl:let* ((v (cl:slot-value self 'test4))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 2433))
      (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated string Test5 = 305;
  (cl:let* ((v (cl:slot-value self 'test5))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 2442))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:aref v i)))))
  ;; repeated group Test6 = 306 {
  (cl:let* ((v (cl:slot-value self 'test6))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 2451))
       (cl:setf index (serialize (cl:aref v i) buffer index limit))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 2452))))
  ;; required fixed64 FixedValue = 310;
  (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2481))
    (cl:setf index (wire-format:write-uint64-carefully buffer index limit (cl:slot-value self 'fixedvalue))))
  ;; required fixed32 FixedValue2 = 311;
  (cl:when (cl:logbitp 12 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2493))
    (cl:setf index (wire-format:write-uint32-carefully buffer index limit (cl:slot-value self 'fixedvalue2))))
  ;; optional .TestMessage Eleven = 312;
  (cl:when (cl:logbitp 14 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2498))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'eleven) '%cached-size%)))
    (cl:setf index (serialize (cl:slot-value self 'eleven) buffer index limit)))
  ;; optional .TestProtocol.AnotherEnum Twelve = 313;
  (cl:when (cl:logbitp 15 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2504))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (base:int32-to-uint64 (cl:slot-value self 'twelve)))))
  ;; optional group Thirteen = 314 {
  (cl:when (cl:logbitp 16 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2515))
    (cl:setf index (serialize (cl:slot-value self 'thirteen) buffer index limit))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2516)))
  index)

(cl:defmethod merge-from-array ((self testprotocol) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
              (cl:type base:octet-vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type base:octet-vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; required string One = 1;
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'one) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional int64 Two = 2 [default = 19];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'two) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated group Four = 4 {
        ((35)
          (cl:let ((message (cl:make-instance 'testprotocol-four)))
            (cl:setf index (merge-from-array message buffer index limit))
            (cl:vector-push-extend message (cl:slot-value self 'four)))
          ;; XXXX: wrong: tag size could be more than one byte
          ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 36)
          ;  (cl:error "bad group merge"))
          )
        ;; optional group Seven = 7 {
        ((59)
          (cl:let ((message (cl:slot-value self 'seven)))
            (cl:when (cl:null message)
              (cl:setf message (cl:make-instance 'testprotocol-seven))
              (cl:setf (cl:slot-value self 'seven) message)
              (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
            (cl:setf index (merge-from-array message buffer index limit))
            ;; XXXX: wrong: tag size could be more than one byte
            ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 60)
            ;  (cl:error "bad group merge"))
            ))
        ;; required string Zero = 63;
        ((506)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'zero) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .TimeProtocol TP2 = 113;
        ((906)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'timeprotocol)))
              (cl:setf index (merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'tp2)))))
        ;; optional string OptString = 299 [default = "opt"];
        ((2394)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'optstring) value)
            (cl:setf (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated int64 Test1 = 301;
        ((2408)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test1))
              (cl:setf index new-index)))
        ;; repeated int32 Test2 = 302;
        ((2416)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test2))
              (cl:setf index new-index)))
        ;; repeated float Test3 = 303;
        ((2429)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-single-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test3))
              (cl:setf index new-index)))
        ;; repeated double Test4 = 304;
        ((2433)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test4))
              (cl:setf index new-index)))
        ;; repeated string Test5 = 305;
        ((2442)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:vector-push-extend value (cl:slot-value self 'test5))
            (cl:setf index new-index)))
        ;; repeated group Test6 = 306 {
        ((2451)
          (cl:let ((message (cl:make-instance 'testprotocol-test6)))
            (cl:setf index (merge-from-array message buffer index limit))
            (cl:vector-push-extend message (cl:slot-value self 'test6)))
          ;; XXXX: wrong: tag size could be more than one byte
          ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 2452)
          ;  (cl:error "bad group merge"))
          )
        ;; required fixed64 FixedValue = 310;
        ((2481)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-uint64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'fixedvalue) value)
            (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; required fixed32 FixedValue2 = 311;
        ((2493)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-uint32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'fixedvalue2) value)
            (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional .TestMessage Eleven = 312;
        ((2498)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'eleven)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'testmessage))
                (cl:setf (cl:slot-value self 'eleven) message)
                (cl:setf (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; optional .TestProtocol.AnotherEnum Twelve = 313;
        ((2504)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'twelve) value)
            (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; optional group Thirteen = 314 {
        ((2515)
          (cl:let ((message (cl:slot-value self 'thirteen)))
            (cl:when (cl:null message)
              (cl:setf message (cl:make-instance 'testprotocol-thirteen))
              (cl:setf (cl:slot-value self 'thirteen) message)
              (cl:setf (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 1))
            (cl:setf index (merge-from-array message buffer index limit))
            ;; XXXX: wrong: tag size could be more than one byte
            ;(cl:unless (cl:= (cl:aref buffer (cl:1- index)) 2516)
            ;  (cl:error "bad group merge"))
            ))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from merge-from-array index))
          ;; Tag 0 is special.  It is used to indicate an error,
          ;; so we return as error code when we see it.
          (cl:when (cl:zerop tag)
            (cl:error "zero tag")))))))

(cl:defmethod merge-from-message ((self testprotocol) (from testprotocol))
  (cl:let* ((v (cl:slot-value self 'four))
            (vf (cl:slot-value from 'four))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'tp2))
            (vf (cl:slot-value from 'tp2))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'test1))
            (vf (cl:slot-value from 'test1))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'test2))
            (vf (cl:slot-value from 'test2))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'test3))
            (vf (cl:slot-value from 'test3))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'test4))
            (vf (cl:slot-value from 'test4))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'test5))
            (vf (cl:slot-value from 'test5))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'test6))
            (vf (cl:slot-value from 'test6))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'zero) (cl:slot-value from 'zero))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'one) (cl:slot-value from 'one))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'two) (cl:slot-value from 'two))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'seven)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'testprotocol-seven))
        (cl:setf (cl:slot-value self 'seven) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (merge-from-message message (cl:slot-value from 'seven))))
  (cl:when (cl:logbitp 11 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'fixedvalue) (cl:slot-value from 'fixedvalue))
    (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 12 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'fixedvalue2) (cl:slot-value from 'fixedvalue2))
    (cl:setf (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 13 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'optstring) (cl:slot-value from 'optstring))
    (cl:setf (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 14 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'eleven)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'testmessage))
        (cl:setf (cl:slot-value self 'eleven) message)
        (cl:setf (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 1))
     (merge-from-message message (cl:slot-value from 'eleven))))
  (cl:when (cl:logbitp 15 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'twelve) (cl:slot-value from 'twelve))
    (cl:setf (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 16 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'thirteen)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'testprotocol-thirteen))
        (cl:setf (cl:slot-value self 'thirteen) message)
        (cl:setf (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 1))
     (merge-from-message message (cl:slot-value from 'thirteen))))
)


