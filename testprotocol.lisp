;;; This file automatically generated by protocol-compiler
;;; DO NOT EDIT!


(cl:in-package #:protocol-buffer)

(cl:defclass TimeProtocol-G (protocol-buffer)
  (
    (v1
     :initform 0
     :type base:int32)

    (v2
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'TimeProtocol-G)


(cl:defun make-TimeProtocol-G ()
  (cl:make-instance 'TimeProtocol-G))
(cl:export 'make-TimeProtocol-G)

(cl:defgeneric v1 (proto))
(cl:defmethod v1 ((self TimeProtocol-G))
  (cl:slot-value self 'v1))

(cl:defgeneric (cl:setf v1) (new-value proto))
(cl:defmethod (cl:setf v1) (new-value (self TimeProtocol-G))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'v1) new-value))

(cl:export 'v1)

(cl:defgeneric v2 (proto))
(cl:defmethod v2 ((self TimeProtocol-G))
  (cl:slot-value self 'v2))

(cl:defgeneric (cl:setf v2) (new-value proto))
(cl:defmethod (cl:setf v2) (new-value (self TimeProtocol-G))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'v2) new-value))

(cl:export 'v2)

(cl:defgeneric has-v1 (proto))
(cl:defmethod has-v1 ((self TimeProtocol-G))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-v1)

(cl:defgeneric has-v2 (proto))
(cl:defmethod has-v2 ((self TimeProtocol-G))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-v2)

(cl:defmethod cl:print-object ((object TimeProtocol-G) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-v1 object)
      (cl:format stream "v1: ~s " (v1 object)))
    (cl:when (has-v2 object)
      (cl:format stream "v2: ~s " (v2 object)))
  )
  (cl:values))

(cl:defgeneric clear-v1 (proto))
(cl:defmethod clear-v1 ((self TimeProtocol-G))
  (cl:setf (cl:slot-value self 'v1) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-v1)

(cl:defgeneric clear-v2 (proto))
(cl:defmethod clear-v2 ((self TimeProtocol-G))
  (cl:setf (cl:slot-value self 'v2) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-v2)

(cl:defmethod clear ((self TimeProtocol-G))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'v1) 0)
  (cl:setf (cl:slot-value self 'v2) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TimeProtocol-G))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b011) #b011))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TimeProtocol-G))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (v1 self))))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (v2 self))))
    (cl:+ size 2)))

(cl:defmethod encode ((pb TimeProtocol-G) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 11))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (v1 pb))))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (v2 pb))))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 12))
  index)

(cl:defmethod merge ((self TimeProtocol-G) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((12)
           (cl:return-from merge index))
          ((16)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'v1) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((24)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'v2) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TimeProtocol (protocol-buffer)
  (
    (g :accessor g
     :initform (cl:make-array 0 :element-type 'TimeProtocol-G :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TimeProtocol-G))

    (debug :accessor debug
     :initform (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:octet-vector))

  ))

(cl:export 'TimeProtocol)


(cl:defun make-TimeProtocol ()
  (cl:make-instance 'TimeProtocol))
(cl:export 'make-TimeProtocol)

(cl:export 'g)

(cl:export 'debug)

(cl:defmethod cl:print-object ((object TimeProtocol) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:format stream "g: ~s " (g object))
    (cl:format stream "debug: ~s " (debug object))
  )
  (cl:values))

(cl:defmethod clear ((self TimeProtocol))
  (cl:setf (cl:slot-value self 'g)
           (cl:make-array 0 :element-type 'TimeProtocol-G :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'debug)
           (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self TimeProtocol))
  (cl:let* ((x (cl:slot-value self 'g))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self TimeProtocol))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:let ((length (cl:length (g self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (g self) i)))))
    (cl:let ((length (cl:length (debug self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (cl:length (cl:aref (debug self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TimeProtocol) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:let* ((v (g pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  (cl:let* ((v (debug pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (cl:aref v i)))
    ))
  index)

(cl:defmethod merge ((self TimeProtocol) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((11)
            (cl:let ((new (make-TimeProtocol-G)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'g)))
          )
          ((34)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'debug))
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestMessage (protocol-buffer)
  (
    (foo
     :initform 0
     :type base:int32)

    (bar
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'TestMessage)


(cl:defun make-TestMessage ()
  (cl:make-instance 'TestMessage))
(cl:export 'make-TestMessage)

(cl:defgeneric foo (proto))
(cl:defmethod foo ((self TestMessage))
  (cl:slot-value self 'foo))

(cl:defgeneric (cl:setf foo) (new-value proto))
(cl:defmethod (cl:setf foo) (new-value (self TestMessage))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'foo) new-value))

(cl:export 'foo)

(cl:defgeneric bar (proto))
(cl:defmethod bar ((self TestMessage))
  (cl:slot-value self 'bar))

(cl:defgeneric (cl:setf bar) (new-value proto))
(cl:defmethod (cl:setf bar) (new-value (self TestMessage))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'bar) new-value))

(cl:export 'bar)

(cl:defgeneric has-foo (proto))
(cl:defmethod has-foo ((self TestMessage))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-foo)

(cl:defgeneric has-bar (proto))
(cl:defmethod has-bar ((self TestMessage))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-bar)

(cl:defmethod cl:print-object ((object TestMessage) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-foo object)
      (cl:format stream "foo: ~s " (foo object)))
    (cl:when (has-bar object)
      (cl:format stream "bar: ~s " (bar object)))
  )
  (cl:values))

(cl:defgeneric clear-foo (proto))
(cl:defmethod clear-foo ((self TestMessage))
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-foo)

(cl:defgeneric clear-bar (proto))
(cl:defmethod clear-bar ((self TestMessage))
  (cl:setf (cl:slot-value self 'bar) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-bar)

(cl:defmethod clear ((self TestMessage))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'foo) 0)
  (cl:setf (cl:slot-value self 'bar) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TestMessage))
  cl:t)

(cl:defmethod octet-size ((self TestMessage))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-foo self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (foo self))))))
    (cl:when (has-bar self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (bar self))))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestMessage) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:when (has-foo pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (foo pb))))
    )
  (cl:when (has-bar pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (bar pb))))
    )
  index)

(cl:defmethod merge ((self TestMessage) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((8)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'foo) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((16)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'bar) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestMessage3 (protocol-buffer)
  (
    (str
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'TestMessage3)


(cl:defun make-TestMessage3 ()
  (cl:make-instance 'TestMessage3))
(cl:export 'make-TestMessage3)

(cl:defgeneric str (proto))
(cl:defmethod str ((self TestMessage3))
  (base:utf8-octets-to-string (cl:slot-value self 'str)))
(cl:defgeneric str-octets (proto))
(cl:defmethod str-octets ((self TestMessage3))
  (cl:slot-value self 'str))
(cl:export 'str)

(cl:defgeneric (cl:setf str) (new-value proto))
(cl:defmethod (cl:setf str) (new-value (self TestMessage3))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'str)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'str) new-value))))

(cl:export 'str)

(cl:defgeneric has-str (proto))
(cl:defmethod has-str ((self TestMessage3))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-str)

(cl:defmethod cl:print-object ((object TestMessage3) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-str object)
      (cl:format stream "str: ~s " (str object)))
  )
  (cl:values))

(cl:defgeneric clear-str (proto))
(cl:defmethod clear-str ((self TestMessage3))
  (cl:setf (cl:slot-value self 'str) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-str)

(cl:defmethod clear ((self TestMessage3))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'str) (base:make-octet-vector 0))
  (cl:values))

(cl:defmethod is-initialized ((self TestMessage3))
  cl:t)

(cl:defmethod octet-size ((self TestMessage3))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-str self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (str-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestMessage3) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:when (has-str pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (str-octets pb)))
    )
  index)

(cl:defmethod merge ((self TestMessage3) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((10)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'str) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestMessage2 (protocol-buffer)
  (
    (s
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (b
     :initform cl:nil
     :type cl:boolean)

    (foreign
     :accessor foreign
     :initform cl:nil
     :type (cl:or cl:null TestMessage3))

    (big_tag
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 4))
  ))

(cl:export 'TestMessage2)


(cl:defun make-TestMessage2 ()
  (cl:make-instance 'TestMessage2))
(cl:export 'make-TestMessage2)

(cl:defgeneric s (proto))
(cl:defmethod s ((self TestMessage2))
  (base:utf8-octets-to-string (cl:slot-value self 's)))
(cl:defgeneric s-octets (proto))
(cl:defmethod s-octets ((self TestMessage2))
  (cl:slot-value self 's))
(cl:export 's)

(cl:defgeneric (cl:setf s) (new-value proto))
(cl:defmethod (cl:setf s) (new-value (self TestMessage2))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 's)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 's) new-value))))

(cl:export 's)

(cl:defgeneric b (proto))
(cl:defmethod b ((self TestMessage2))
  (cl:slot-value self 'b))

(cl:defgeneric (cl:setf b) (new-value proto))
(cl:defmethod (cl:setf b) (new-value (self TestMessage2))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'b) new-value))

(cl:export 'b)

(cl:defgeneric foreign (proto))
(cl:defmethod foreign ((self TestMessage2))
  (cl:when (cl:null (cl:slot-value self 'foreign))
    (cl:setf
      (cl:ldb (cl:byte 1 2)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'foreign)
             (make-TestMessage3)))
  (cl:slot-value self 'foreign))

(cl:defgeneric (cl:setf foreign) (new-value proto))
(cl:defmethod (cl:setf foreign) (new-value (self TestMessage2))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'foreign) new-value))

(cl:export 'foreign)

(cl:defgeneric big_tag (proto))
(cl:defmethod big_tag ((self TestMessage2))
  (cl:slot-value self 'big_tag))

(cl:defgeneric (cl:setf big_tag) (new-value proto))
(cl:defmethod (cl:setf big_tag) (new-value (self TestMessage2))
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'big_tag) new-value))

(cl:export 'big_tag)

(cl:defgeneric has-s (proto))
(cl:defmethod has-s ((self TestMessage2))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-s)

(cl:defgeneric has-b (proto))
(cl:defmethod has-b ((self TestMessage2))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-b)

(cl:defgeneric has-foreign (proto))
(cl:defmethod has-foreign ((self TestMessage2))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-foreign)

(cl:defgeneric has-big_tag (proto))
(cl:defmethod has-big_tag ((self TestMessage2))
  (cl:= (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-big_tag)

(cl:defmethod cl:print-object ((object TestMessage2) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-s object)
      (cl:format stream "s: ~s " (s object)))
    (cl:when (has-b object)
      (cl:format stream "b: ~s " (b object)))
    (cl:when (has-foreign object)
      (cl:format stream "foreign: ~s " (foreign object)))
    (cl:when (has-big_tag object)
      (cl:format stream "big_tag: ~s " (big_tag object)))
  )
  (cl:values))

(cl:defgeneric clear-s (proto))
(cl:defmethod clear-s ((self TestMessage2))
  (cl:setf (cl:slot-value self 's) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-s)

(cl:defgeneric clear-b (proto))
(cl:defmethod clear-b ((self TestMessage2))
  (cl:setf (cl:slot-value self 'b) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-b)

(cl:defgeneric clear-foreign (proto))
(cl:defmethod clear-foreign ((self TestMessage2))
  (cl:setf (cl:slot-value self 'foreign) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-foreign)

(cl:defgeneric clear-big_tag (proto))
(cl:defmethod clear-big_tag ((self TestMessage2))
  (cl:setf (cl:slot-value self 'big_tag) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-big_tag)

(cl:defmethod clear ((self TestMessage2))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 's) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'b) cl:nil)
  (cl:setf (cl:slot-value self 'foreign) cl:nil)
  (cl:setf (cl:slot-value self 'big_tag) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TestMessage2))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 2)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'foreign))))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestMessage2))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-s self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (s-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-b self) (cl:incf size 2))
    (cl:when (has-foreign self) (cl:incf size (cl:+ 1 (cl:let ((x (octet-size (foreign self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-big_tag self) (cl:incf size (cl:+ 3 (varint:length64 (base:int32-to-uint64 (big_tag self))))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestMessage2) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:when (has-s pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (s-octets pb)))
    )
  (cl:when (has-b pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (b pb)))
    )
  (cl:when (has-foreign pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:let ((size (octet-size (foreign pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (foreign pb) buffer index limit)))
    )
  (cl:when (has-big_tag pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40000))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (big_tag pb))))
    )
  index)

(cl:defmethod merge ((self TestMessage2) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((10)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 's) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((16)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'b) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((26)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (foreign self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          ((40000)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'big_tag) value)
              (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestProtocol-FourSevenTwelve (protocol-buffer)
  (
    (thirteen
     :initform cl:nil
     :type cl:boolean)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'TestProtocol-FourSevenTwelve)


(cl:defun make-TestProtocol-FourSevenTwelve ()
  (cl:make-instance 'TestProtocol-FourSevenTwelve))
(cl:export 'make-TestProtocol-FourSevenTwelve)

(cl:defgeneric thirteen (proto))
(cl:defmethod thirteen ((self TestProtocol-FourSevenTwelve))
  (cl:slot-value self 'thirteen))

(cl:defgeneric (cl:setf thirteen) (new-value proto))
(cl:defmethod (cl:setf thirteen) (new-value (self TestProtocol-FourSevenTwelve))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'thirteen) new-value))

(cl:export 'thirteen)

(cl:defgeneric has-thirteen (proto))
(cl:defmethod has-thirteen ((self TestProtocol-FourSevenTwelve))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-thirteen)

(cl:defmethod cl:print-object ((object TestProtocol-FourSevenTwelve) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-thirteen object)
      (cl:format stream "thirteen: ~s " (thirteen object)))
  )
  (cl:values))

(cl:defgeneric clear-thirteen (proto))
(cl:defmethod clear-thirteen ((self TestProtocol-FourSevenTwelve))
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-thirteen)

(cl:defmethod clear ((self TestProtocol-FourSevenTwelve))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol-FourSevenTwelve))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol-FourSevenTwelve))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-thirteen self) (cl:incf size 3))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestProtocol-FourSevenTwelve) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 539))
  (cl:when (has-thirteen pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 544))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (thirteen pb)))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 540))
  index)

(cl:defmethod merge ((self TestProtocol-FourSevenTwelve) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((540)
           (cl:return-from merge index))
          ((544)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'thirteen) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestProtocol-FourSeven (protocol-buffer)
  (
    (four
     :initform cl:nil
     :type cl:boolean)

    (twelve
     :accessor twelve
     :initform cl:nil
     :type (cl:or cl:null TestProtocol-FourSevenTwelve))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'TestProtocol-FourSeven)


(cl:defun make-TestProtocol-FourSeven ()
  (cl:make-instance 'TestProtocol-FourSeven))
(cl:export 'make-TestProtocol-FourSeven)

(cl:defgeneric four (proto))
(cl:defmethod four ((self TestProtocol-FourSeven))
  (cl:slot-value self 'four))

(cl:defgeneric (cl:setf four) (new-value proto))
(cl:defmethod (cl:setf four) (new-value (self TestProtocol-FourSeven))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'four) new-value))

(cl:export 'four)

(cl:defgeneric twelve (proto))
(cl:defmethod twelve ((self TestProtocol-FourSeven))
  (cl:when (cl:null (cl:slot-value self 'twelve))
    (cl:setf
      (cl:ldb (cl:byte 1 1)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'twelve)
             (make-TestProtocol-FourSevenTwelve)))
  (cl:slot-value self 'twelve))

(cl:defgeneric (cl:setf twelve) (new-value proto))
(cl:defmethod (cl:setf twelve) (new-value (self TestProtocol-FourSeven))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'twelve) new-value))

(cl:export 'twelve)

(cl:defgeneric has-four (proto))
(cl:defmethod has-four ((self TestProtocol-FourSeven))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-four)

(cl:defgeneric has-twelve (proto))
(cl:defmethod has-twelve ((self TestProtocol-FourSeven))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-twelve)

(cl:defmethod cl:print-object ((object TestProtocol-FourSeven) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-four object)
      (cl:format stream "four: ~s " (four object)))
    (cl:when (has-twelve object)
      (cl:format stream "twelve: ~s " (twelve object)))
  )
  (cl:values))

(cl:defgeneric clear-four (proto))
(cl:defmethod clear-four ((self TestProtocol-FourSeven))
  (cl:setf (cl:slot-value self 'four) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-four)

(cl:defgeneric clear-twelve (proto))
(cl:defmethod clear-twelve ((self TestProtocol-FourSeven))
  (cl:setf (cl:slot-value self 'twelve) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-twelve)

(cl:defmethod clear ((self TestProtocol-FourSeven))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'four) cl:nil)
  (cl:setf (cl:slot-value self 'twelve) cl:nil)
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol-FourSeven))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 1)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'twelve))))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol-FourSeven))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-four self) (cl:incf size 3))
    (cl:when (has-twelve self) (cl:incf size (cl:+ 4 (octet-size (twelve self)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestProtocol-FourSeven) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 523))
  (cl:when (has-four pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 528))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (four pb)))
    )
  (cl:when (has-twelve pb)
    (cl:setf index (encode (twelve pb) buffer index limit))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 524))
  index)

(cl:defmethod merge ((self TestProtocol-FourSeven) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((524)
           (cl:return-from merge index))
          ((528)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'four) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((539)
            (cl:let ((new-index (merge (twelve self) buffer index limit)))
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defconstant +TestProtocol-Four-DELETE_ME_TO_CRASH_SWIG+ 0)
(cl:export '+TestProtocol-Four-DELETE_ME_TO_CRASH_SWIG+)

(cl:defclass TestProtocol-Four (protocol-buffer)
  (
    (five
     :initform 0
     :type base:int64)

    (six
     :initform 0
     :type base:uint64)

    (tp
     :accessor tp
     :initform cl:nil
     :type (cl:or cl:null TimeProtocol))

    (seven :accessor seven
     :initform (cl:make-array 0 :element-type 'TestProtocol-FourSeven :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TestProtocol-FourSeven))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 3))
  ))

(cl:export 'TestProtocol-Four)


(cl:defun make-TestProtocol-Four ()
  (cl:make-instance 'TestProtocol-Four))
(cl:export 'make-TestProtocol-Four)

(cl:defgeneric five (proto))
(cl:defmethod five ((self TestProtocol-Four))
  (cl:slot-value self 'five))

(cl:defgeneric (cl:setf five) (new-value proto))
(cl:defmethod (cl:setf five) (new-value (self TestProtocol-Four))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'five) new-value))

(cl:export 'five)

(cl:defgeneric six (proto))
(cl:defmethod six ((self TestProtocol-Four))
  (cl:slot-value self 'six))

(cl:defgeneric (cl:setf six) (new-value proto))
(cl:defmethod (cl:setf six) (new-value (self TestProtocol-Four))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'six) new-value))

(cl:export 'six)

(cl:defgeneric tp (proto))
(cl:defmethod tp ((self TestProtocol-Four))
  (cl:when (cl:null (cl:slot-value self 'tp))
    (cl:setf
      (cl:ldb (cl:byte 1 2)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'tp)
             (make-TimeProtocol)))
  (cl:slot-value self 'tp))

(cl:defgeneric (cl:setf tp) (new-value proto))
(cl:defmethod (cl:setf tp) (new-value (self TestProtocol-Four))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'tp) new-value))

(cl:export 'tp)

(cl:export 'seven)

(cl:defgeneric has-five (proto))
(cl:defmethod has-five ((self TestProtocol-Four))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-five)

(cl:defgeneric has-six (proto))
(cl:defmethod has-six ((self TestProtocol-Four))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-six)

(cl:defgeneric has-tp (proto))
(cl:defmethod has-tp ((self TestProtocol-Four))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-tp)

(cl:defmethod cl:print-object ((object TestProtocol-Four) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-five object)
      (cl:format stream "five: ~s " (five object)))
    (cl:when (has-six object)
      (cl:format stream "six: ~s " (six object)))
    (cl:when (has-tp object)
      (cl:format stream "tp: ~s " (tp object)))
    (cl:format stream "seven: ~s " (seven object))
  )
  (cl:values))

(cl:defgeneric clear-five (proto))
(cl:defmethod clear-five ((self TestProtocol-Four))
  (cl:setf (cl:slot-value self 'five) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-five)

(cl:defgeneric clear-six (proto))
(cl:defmethod clear-six ((self TestProtocol-Four))
  (cl:setf (cl:slot-value self 'six) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-six)

(cl:defgeneric clear-tp (proto))
(cl:defmethod clear-tp ((self TestProtocol-Four))
  (cl:setf (cl:slot-value self 'tp) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-tp)

(cl:defmethod clear ((self TestProtocol-Four))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'five) 0)
  (cl:setf (cl:slot-value self 'six) 0)
  (cl:setf (cl:slot-value self 'tp) cl:nil)
  (cl:setf (cl:slot-value self 'seven)
           (cl:make-array 0 :element-type 'TestProtocol-FourSeven :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol-Four))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b011) #b011))
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 2)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'tp))))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'seven))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol-Four))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int64-to-uint64 (five self))))
    (cl:incf size (varint:length64 (six self)))
    (cl:when (has-tp self) (cl:incf size (cl:+ 2 (cl:let ((x (octet-size (tp self)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (seven self))))
      (cl:incf size (cl:* 4 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (seven self) i)))))
    (cl:+ size 3)))

(cl:defmethod encode ((pb TestProtocol-Four) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 35))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (five pb))))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 512))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit (six pb)))
  (cl:let* ((v (seven pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  (cl:when (has-tp pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 898))
    (cl:let ((size (octet-size (tp pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (tp pb) buffer index limit)))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 36))
  index)

(cl:defmethod merge ((self TestProtocol-Four) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((36)
           (cl:return-from merge index))
          ((40)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'five) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((512)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-uint64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'six) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((898)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (tp self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          ((523)
            (cl:let ((new (make-TestProtocol-FourSeven)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'seven)))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestProtocol-Seven (protocol-buffer)
  (
    (eight
     :initform 0
     :type base:int64)

    (nine
     :initform cl:nil
     :type cl:boolean)

    (ten
     :initform cl:t
     :type cl:boolean)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 3))
  ))

(cl:export 'TestProtocol-Seven)


(cl:defun make-TestProtocol-Seven ()
  (cl:make-instance 'TestProtocol-Seven))
(cl:export 'make-TestProtocol-Seven)

(cl:defgeneric eight (proto))
(cl:defmethod eight ((self TestProtocol-Seven))
  (cl:slot-value self 'eight))

(cl:defgeneric (cl:setf eight) (new-value proto))
(cl:defmethod (cl:setf eight) (new-value (self TestProtocol-Seven))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'eight) new-value))

(cl:export 'eight)

(cl:defgeneric nine (proto))
(cl:defmethod nine ((self TestProtocol-Seven))
  (cl:slot-value self 'nine))

(cl:defgeneric (cl:setf nine) (new-value proto))
(cl:defmethod (cl:setf nine) (new-value (self TestProtocol-Seven))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'nine) new-value))

(cl:export 'nine)

(cl:defgeneric ten (proto))
(cl:defmethod ten ((self TestProtocol-Seven))
  (cl:slot-value self 'ten))

(cl:defgeneric (cl:setf ten) (new-value proto))
(cl:defmethod (cl:setf ten) (new-value (self TestProtocol-Seven))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'ten) new-value))

(cl:export 'ten)

(cl:defgeneric has-eight (proto))
(cl:defmethod has-eight ((self TestProtocol-Seven))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-eight)

(cl:defgeneric has-nine (proto))
(cl:defmethod has-nine ((self TestProtocol-Seven))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-nine)

(cl:defgeneric has-ten (proto))
(cl:defmethod has-ten ((self TestProtocol-Seven))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-ten)

(cl:defmethod cl:print-object ((object TestProtocol-Seven) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-eight object)
      (cl:format stream "eight: ~s " (eight object)))
    (cl:when (has-nine object)
      (cl:format stream "nine: ~s " (nine object)))
    (cl:when (has-ten object)
      (cl:format stream "ten: ~s " (ten object)))
  )
  (cl:values))

(cl:defgeneric clear-eight (proto))
(cl:defmethod clear-eight ((self TestProtocol-Seven))
  (cl:setf (cl:slot-value self 'eight) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-eight)

(cl:defgeneric clear-nine (proto))
(cl:defmethod clear-nine ((self TestProtocol-Seven))
  (cl:setf (cl:slot-value self 'nine) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-nine)

(cl:defgeneric clear-ten (proto))
(cl:defmethod clear-ten ((self TestProtocol-Seven))
  (cl:setf (cl:slot-value self 'ten) cl:t)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-ten)

(cl:defmethod clear ((self TestProtocol-Seven))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'eight) 0)
  (cl:setf (cl:slot-value self 'nine) cl:nil)
  (cl:setf (cl:slot-value self 'ten) cl:t)
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol-Seven))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b0011) #b0011))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol-Seven))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int64-to-uint64 (eight self))))
    (cl:when (has-ten self) (cl:incf size 2))
    (cl:+ size 3)))

(cl:defmethod encode ((pb TestProtocol-Seven) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 59))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 64))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (eight pb))))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 72))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (nine pb)))
  (cl:when (has-ten pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 80))
    (cl:setf index
     (protocol:write-boolean-carefully buffer index limit (ten pb)))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 60))
  index)

(cl:defmethod merge ((self TestProtocol-Seven) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((60)
           (cl:return-from merge index))
          ((64)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'eight) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((72)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'nine) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((80)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-boolean-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'ten) value)
              (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestProtocol-Test6 (protocol-buffer)
  (
  ))

(cl:export 'TestProtocol-Test6)


(cl:defun make-TestProtocol-Test6 ()
  (cl:make-instance 'TestProtocol-Test6))
(cl:export 'make-TestProtocol-Test6)

(cl:defmethod cl:print-object ((object TestProtocol-Test6) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
  )
  (cl:values))

(cl:defmethod clear ((self TestProtocol-Test6))
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol-Test6))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol-Test6))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestProtocol-Test6) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 2451))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 2452))
  index)

(cl:defmethod merge ((self TestProtocol-Test6) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((2452)
           (cl:return-from merge index))
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestProtocol-Thirteen (protocol-buffer)
  (
    (fourteen
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'TestProtocol-Thirteen)


(cl:defun make-TestProtocol-Thirteen ()
  (cl:make-instance 'TestProtocol-Thirteen))
(cl:export 'make-TestProtocol-Thirteen)

(cl:defgeneric fourteen (proto))
(cl:defmethod fourteen ((self TestProtocol-Thirteen))
  (cl:slot-value self 'fourteen))

(cl:defgeneric (cl:setf fourteen) (new-value proto))
(cl:defmethod (cl:setf fourteen) (new-value (self TestProtocol-Thirteen))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'fourteen) new-value))

(cl:export 'fourteen)

(cl:defgeneric has-fourteen (proto))
(cl:defmethod has-fourteen ((self TestProtocol-Thirteen))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-fourteen)

(cl:defmethod cl:print-object ((object TestProtocol-Thirteen) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-fourteen object)
      (cl:format stream "fourteen: ~s " (fourteen object)))
  )
  (cl:values))

(cl:defgeneric clear-fourteen (proto))
(cl:defmethod clear-fourteen ((self TestProtocol-Thirteen))
  (cl:setf (cl:slot-value self 'fourteen) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-fourteen)

(cl:defmethod clear ((self TestProtocol-Thirteen))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'fourteen) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol-Thirteen))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b01) #b01))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol-Thirteen))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (fourteen self))))
    (cl:+ size 2)))

(cl:defmethod encode ((pb TestProtocol-Thirteen) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 2515))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2520))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (fourteen pb))))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 2516))
  index)

(cl:defmethod merge ((self TestProtocol-Thirteen) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((2516)
           (cl:return-from merge index))
          ((2520)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'fourteen) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defconstant +TestProtocol-ENUM_ZERO+ 0)
(cl:export '+TestProtocol-ENUM_ZERO+)
(cl:defconstant +TestProtocol-ENUM_ONE+ 1)
(cl:export '+TestProtocol-ENUM_ONE+)
(cl:defconstant +TestProtocol-ENUM_TWO_REALLY_LONG_NAME+ 2)
(cl:export '+TestProtocol-ENUM_TWO_REALLY_LONG_NAME+)

(cl:defconstant +TestProtocol-ENUM_WHATEVER+ 0)
(cl:export '+TestProtocol-ENUM_WHATEVER+)

(cl:defclass TestProtocol (protocol-buffer)
  (
    (zero
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (one
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (two
     :initform 19
     :type base:int64)

    (four :accessor four
     :initform (cl:make-array 0 :element-type 'TestProtocol-Four :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TestProtocol-Four))

    (seven
     :accessor seven
     :initform cl:nil
     :type (cl:or cl:null TestProtocol-Seven))

    (tp2 :accessor tp2
     :initform (cl:make-array 0 :element-type 'TimeProtocol :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TimeProtocol))

    (test1 :accessor test1
     :initform (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int64))

    (test2 :accessor test2
     :initform (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int32))

    (test3 :accessor test3
     :initform (cl:make-array 0 :element-type 'cl:single-float :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:single-float))

    (test4 :accessor test4
     :initform (cl:make-array 0 :element-type 'cl:double-float :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:double-float))

    (test5 :accessor test5
     :initform (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:octet-vector))

    (fixedvalue
     :initform 0
     :type base:int64)

    (fixedvalue2
     :initform 0
     :type base:int32)

    (optstring
     :initform (base:string-to-utf8-octets "opt")
     :type base:octet-vector)

    (eleven
     :accessor eleven
     :initform cl:nil
     :type (cl:or cl:null TestMessage))

    (twelve
     :initform 0
     :type base:int32)

    (thirteen
     :accessor thirteen
     :initform cl:nil
     :type (cl:or cl:null TestProtocol-Thirteen))

    (test6 :accessor test6
     :initform (cl:make-array 0 :element-type 'TestProtocol-Test6 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TestProtocol-Test6))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 10))
  ))

(cl:export 'TestProtocol)


(cl:defun make-TestProtocol ()
  (cl:make-instance 'TestProtocol))
(cl:export 'make-TestProtocol)

(cl:defgeneric zero (proto))
(cl:defmethod zero ((self TestProtocol))
  (base:utf8-octets-to-string (cl:slot-value self 'zero)))
(cl:defgeneric zero-octets (proto))
(cl:defmethod zero-octets ((self TestProtocol))
  (cl:slot-value self 'zero))
(cl:export 'zero)

(cl:defgeneric (cl:setf zero) (new-value proto))
(cl:defmethod (cl:setf zero) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'zero)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'zero) new-value))))

(cl:export 'zero)

(cl:defgeneric one (proto))
(cl:defmethod one ((self TestProtocol))
  (base:utf8-octets-to-string (cl:slot-value self 'one)))
(cl:defgeneric one-octets (proto))
(cl:defmethod one-octets ((self TestProtocol))
  (cl:slot-value self 'one))
(cl:export 'one)

(cl:defgeneric (cl:setf one) (new-value proto))
(cl:defmethod (cl:setf one) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'one)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'one) new-value))))

(cl:export 'one)

(cl:defgeneric two (proto))
(cl:defmethod two ((self TestProtocol))
  (cl:slot-value self 'two))

(cl:defgeneric (cl:setf two) (new-value proto))
(cl:defmethod (cl:setf two) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'two) new-value))

(cl:export 'two)

(cl:export 'four)

(cl:defgeneric seven (proto))
(cl:defmethod seven ((self TestProtocol))
  (cl:when (cl:null (cl:slot-value self 'seven))
    (cl:setf
      (cl:ldb (cl:byte 1 3)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'seven)
             (make-TestProtocol-Seven)))
  (cl:slot-value self 'seven))

(cl:defgeneric (cl:setf seven) (new-value proto))
(cl:defmethod (cl:setf seven) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'seven) new-value))

(cl:export 'seven)

(cl:export 'tp2)

(cl:export 'test1)

(cl:export 'test2)

(cl:export 'test3)

(cl:export 'test4)

(cl:export 'test5)

(cl:defgeneric fixedvalue (proto))
(cl:defmethod fixedvalue ((self TestProtocol))
  (cl:slot-value self 'fixedvalue))

(cl:defgeneric (cl:setf fixedvalue) (new-value proto))
(cl:defmethod (cl:setf fixedvalue) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'fixedvalue) new-value))

(cl:export 'fixedvalue)

(cl:defgeneric fixedvalue2 (proto))
(cl:defmethod fixedvalue2 ((self TestProtocol))
  (cl:slot-value self 'fixedvalue2))

(cl:defgeneric (cl:setf fixedvalue2) (new-value proto))
(cl:defmethod (cl:setf fixedvalue2) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'fixedvalue2) new-value))

(cl:export 'fixedvalue2)

(cl:defgeneric optstring (proto))
(cl:defmethod optstring ((self TestProtocol))
  (base:utf8-octets-to-string (cl:slot-value self 'optstring)))
(cl:defgeneric optstring-octets (proto))
(cl:defmethod optstring-octets ((self TestProtocol))
  (cl:slot-value self 'optstring))
(cl:export 'optstring)

(cl:defgeneric (cl:setf optstring) (new-value proto))
(cl:defmethod (cl:setf optstring) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 'optstring)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 'optstring) new-value))))

(cl:export 'optstring)

(cl:defgeneric eleven (proto))
(cl:defmethod eleven ((self TestProtocol))
  (cl:when (cl:null (cl:slot-value self 'eleven))
    (cl:setf
      (cl:ldb (cl:byte 1 7)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'eleven)
             (make-TestMessage)))
  (cl:slot-value self 'eleven))

(cl:defgeneric (cl:setf eleven) (new-value proto))
(cl:defmethod (cl:setf eleven) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'eleven) new-value))

(cl:export 'eleven)

(cl:defgeneric twelve (proto))
(cl:defmethod twelve ((self TestProtocol))
  (cl:slot-value self 'twelve))

(cl:defgeneric (cl:setf twelve) (new-value proto))
(cl:defmethod (cl:setf twelve) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'twelve) new-value))

(cl:export 'twelve)

(cl:defgeneric thirteen (proto))
(cl:defmethod thirteen ((self TestProtocol))
  (cl:when (cl:null (cl:slot-value self 'thirteen))
    (cl:setf
      (cl:ldb (cl:byte 1 9)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'thirteen)
             (make-TestProtocol-Thirteen)))
  (cl:slot-value self 'thirteen))

(cl:defgeneric (cl:setf thirteen) (new-value proto))
(cl:defmethod (cl:setf thirteen) (new-value (self TestProtocol))
  (cl:setf
    (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'thirteen) new-value))

(cl:export 'thirteen)

(cl:export 'test6)

(cl:defgeneric has-zero (proto))
(cl:defmethod has-zero ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-zero)

(cl:defgeneric has-one (proto))
(cl:defmethod has-one ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-one)

(cl:defgeneric has-two (proto))
(cl:defmethod has-two ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-two)

(cl:defgeneric has-seven (proto))
(cl:defmethod has-seven ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-seven)

(cl:defgeneric has-fixedvalue (proto))
(cl:defmethod has-fixedvalue ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-fixedvalue)

(cl:defgeneric has-fixedvalue2 (proto))
(cl:defmethod has-fixedvalue2 ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-fixedvalue2)

(cl:defgeneric has-optstring (proto))
(cl:defmethod has-optstring ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-optstring)

(cl:defgeneric has-eleven (proto))
(cl:defmethod has-eleven ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-eleven)

(cl:defgeneric has-twelve (proto))
(cl:defmethod has-twelve ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-twelve)

(cl:defgeneric has-thirteen (proto))
(cl:defmethod has-thirteen ((self TestProtocol))
  (cl:= (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-thirteen)

(cl:defmethod cl:print-object ((object TestProtocol) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-zero object)
      (cl:format stream "zero: ~s " (zero object)))
    (cl:when (has-one object)
      (cl:format stream "one: ~s " (one object)))
    (cl:when (has-two object)
      (cl:format stream "two: ~s " (two object)))
    (cl:format stream "four: ~s " (four object))
    (cl:when (has-seven object)
      (cl:format stream "seven: ~s " (seven object)))
    (cl:format stream "tp2: ~s " (tp2 object))
    (cl:format stream "test1: ~s " (test1 object))
    (cl:format stream "test2: ~s " (test2 object))
    (cl:format stream "test3: ~s " (test3 object))
    (cl:format stream "test4: ~s " (test4 object))
    (cl:format stream "test5: ~s " (test5 object))
    (cl:when (has-fixedvalue object)
      (cl:format stream "fixedvalue: ~s " (fixedvalue object)))
    (cl:when (has-fixedvalue2 object)
      (cl:format stream "fixedvalue2: ~s " (fixedvalue2 object)))
    (cl:when (has-optstring object)
      (cl:format stream "optstring: ~s " (optstring object)))
    (cl:when (has-eleven object)
      (cl:format stream "eleven: ~s " (eleven object)))
    (cl:when (has-twelve object)
      (cl:format stream "twelve: ~s " (twelve object)))
    (cl:when (has-thirteen object)
      (cl:format stream "thirteen: ~s " (thirteen object)))
    (cl:format stream "test6: ~s " (test6 object))
  )
  (cl:values))

(cl:defgeneric clear-zero (proto))
(cl:defmethod clear-zero ((self TestProtocol))
  (cl:setf (cl:slot-value self 'zero) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-zero)

(cl:defgeneric clear-one (proto))
(cl:defmethod clear-one ((self TestProtocol))
  (cl:setf (cl:slot-value self 'one) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-one)

(cl:defgeneric clear-two (proto))
(cl:defmethod clear-two ((self TestProtocol))
  (cl:setf (cl:slot-value self 'two) 19)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-two)

(cl:defgeneric clear-seven (proto))
(cl:defmethod clear-seven ((self TestProtocol))
  (cl:setf (cl:slot-value self 'seven) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-seven)

(cl:defgeneric clear-fixedvalue (proto))
(cl:defmethod clear-fixedvalue ((self TestProtocol))
  (cl:setf (cl:slot-value self 'fixedvalue) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-fixedvalue)

(cl:defgeneric clear-fixedvalue2 (proto))
(cl:defmethod clear-fixedvalue2 ((self TestProtocol))
  (cl:setf (cl:slot-value self 'fixedvalue2) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 12) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-fixedvalue2)

(cl:defgeneric clear-optstring (proto))
(cl:defmethod clear-optstring ((self TestProtocol))
  (cl:setf (cl:slot-value self 'optstring) (base:string-to-utf8-octets "opt"))
  (cl:setf
    (cl:ldb (cl:byte 1 13) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-optstring)

(cl:defgeneric clear-eleven (proto))
(cl:defmethod clear-eleven ((self TestProtocol))
  (cl:setf (cl:slot-value self 'eleven) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 14) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-eleven)

(cl:defgeneric clear-twelve (proto))
(cl:defmethod clear-twelve ((self TestProtocol))
  (cl:setf (cl:slot-value self 'twelve) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 15) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-twelve)

(cl:defgeneric clear-thirteen (proto))
(cl:defmethod clear-thirteen ((self TestProtocol))
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 16) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-thirteen)

(cl:defmethod clear ((self TestProtocol))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'zero) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'one) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'two) 19)
  (cl:setf (cl:slot-value self 'four)
           (cl:make-array 0 :element-type 'TestProtocol-Four :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'seven) cl:nil)
  (cl:setf (cl:slot-value self 'tp2)
           (cl:make-array 0 :element-type 'TimeProtocol :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test1)
           (cl:make-array 0 :element-type 'base:int64 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test2)
           (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test3)
           (cl:make-array 0 :element-type 'cl:single-float :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test4)
           (cl:make-array 0 :element-type 'cl:double-float :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'test5)
           (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'fixedvalue) 0)
  (cl:setf (cl:slot-value self 'fixedvalue2) 0)
  (cl:setf (cl:slot-value self 'optstring) (base:string-to-utf8-octets "opt"))
  (cl:setf (cl:slot-value self 'eleven) cl:nil)
  (cl:setf (cl:slot-value self 'twelve) 0)
  (cl:setf (cl:slot-value self 'thirteen) cl:nil)
  (cl:setf (cl:slot-value self 'test6)
           (cl:make-array 0 :element-type 'TestProtocol-Test6 :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self TestProtocol))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b00011011) #b00011011))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'four))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 3)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'seven))))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'tp2))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 7)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'eleven))))
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 9)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'thirteen))))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'test6))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self TestProtocol))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (cl:let ((x (cl:length (zero-octets self)))) (cl:+ (varint:length32 x) x)))
    (cl:incf size (cl:let ((x (cl:length (one-octets self)))) (cl:+ (varint:length32 x) x)))
    (cl:when (has-two self) (cl:incf size (cl:+ 1 (varint:length64 (base:int64-to-uint64 (two self))))))
    (cl:let ((length (cl:length (four self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (four self) i)))))
    (cl:when (has-seven self) (cl:incf size (cl:+ 2 (octet-size (seven self)))))
    (cl:let ((length (cl:length (tp2 self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (octet-size (cl:aref (tp2 self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (test1 self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int64-to-uint64 (cl:aref (test1 self) i))))))
    (cl:let ((length (cl:length (test2 self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int32-to-uint64 (cl:aref (test2 self) i))))))
    (cl:incf size (cl:* 6 (cl:length (test3 self))))
    (cl:incf size (cl:* 10 (cl:length (test4 self))))
    (cl:let ((length (cl:length (test5 self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (cl:length (cl:aref (test5 self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-optstring self) (cl:incf size (cl:+ 2 (cl:let ((x (cl:length (optstring-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-eleven self) (cl:incf size (cl:+ 2 (cl:let ((x (octet-size (eleven self)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-twelve self) (cl:incf size (cl:+ 2 (varint:length64 (base:int32-to-uint64 (twelve self))))))
    (cl:when (has-thirteen self) (cl:incf size (cl:+ 4 (octet-size (thirteen self)))))
    (cl:let ((length (cl:length (test6 self))))
      (cl:incf size (cl:* 4 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (test6 self) i)))))
    (cl:+ size 19)))

(cl:defmethod encode ((pb TestProtocol) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (one-octets pb)))
  (cl:when (has-two pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (two pb))))
    )
  (cl:let* ((v (four pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  (cl:when (has-seven pb)
    (cl:setf index (encode (seven pb) buffer index limit))
    )
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 506))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (zero-octets pb)))
  (cl:let* ((v (tp2 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 906))
    (cl:let ((size (octet-size (cl:aref v i))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (cl:aref v i) buffer index limit)))
    ))
  (cl:when (has-optstring pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2394))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (optstring-octets pb)))
    )
  (cl:let* ((v (test1 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2408))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int64-to-uint64 (cl:aref v i))))
    ))
  (cl:let* ((v (test2 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2416))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (cl:aref v i))))
    ))
  (cl:let* ((v (test3 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2429))
    (cl:setf index
     (protocol:write-single-float-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (test4 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2433))
    (cl:setf index
     (protocol:write-double-float-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (test5 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2442))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:let* ((v (test6 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2481))
    (cl:setf index
     (protocol:write-int64-carefully buffer index limit (fixedvalue pb)))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2493))
    (cl:setf index
     (protocol:write-int32-carefully buffer index limit (fixedvalue2 pb)))
  (cl:when (has-eleven pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2498))
    (cl:let ((size (octet-size (eleven pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (eleven pb) buffer index limit)))
    )
  (cl:when (has-twelve pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2504))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (twelve pb))))
    )
  (cl:when (has-thirteen pb)
    (cl:setf index (encode (thirteen pb) buffer index limit))
    )
  index)

(cl:defmethod merge ((self TestProtocol) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((506)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'zero) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((10)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'one) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((16)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'two) value)
              (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((35)
            (cl:let ((new (make-TestProtocol-Four)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'four)))
          )
          ((59)
            (cl:let ((new-index (merge (seven self) buffer index limit)))
              (cl:setf index new-index))
          )
          ((906)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:let ((new (make-TimeProtocol)))
                (cl:setf index (merge new buffer new-index (cl:+ new-index length)))
                (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                  (cl:error "buffer overflow"))
                (cl:vector-push-extend new (cl:slot-value self 'tp2))))
          )
          ((2408)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int64-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test1))
              (cl:setf index new-index))
          )
          ((2416)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test2))
              (cl:setf index new-index))
          )
          ((2429)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-single-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test3))
              (cl:setf index new-index))
          )
          ((2433)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-double-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test4))
              (cl:setf index new-index))
          )
          ((2442)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test5))
              (cl:setf index new-index))
          )
          ((2481)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int64-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'fixedvalue) value)
              (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((2493)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'fixedvalue2) value)
              (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((2394)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'optstring) value)
              (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((2498)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (eleven self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          ((2504)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'twelve) value)
              (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((2515)
            (cl:let ((new-index (merge (thirteen self) buffer index limit)))
              (cl:setf index new-index))
          )
          ((2451)
            (cl:let ((new (make-TestProtocol-Test6)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'test6)))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass SimpleTestProtocol (protocol-buffer)
  (
    (test5 :accessor test5
     :initform (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:octet-vector))

  ))

(cl:export 'SimpleTestProtocol)


(cl:defun make-SimpleTestProtocol ()
  (cl:make-instance 'SimpleTestProtocol))
(cl:export 'make-SimpleTestProtocol)

(cl:export 'test5)

(cl:defmethod cl:print-object ((object SimpleTestProtocol) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:format stream "test5: ~s " (test5 object))
  )
  (cl:values))

(cl:defmethod clear ((self SimpleTestProtocol))
  (cl:setf (cl:slot-value self 'test5)
           (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self SimpleTestProtocol))
  cl:t)

(cl:defmethod octet-size ((self SimpleTestProtocol))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:let ((length (cl:length (test5 self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (cl:length (cl:aref (test5 self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb SimpleTestProtocol) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:let* ((v (test5 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2442))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (cl:aref v i)))
    ))
  index)

(cl:defmethod merge ((self SimpleTestProtocol) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((2442)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test5))
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass SimpleTestArray (protocol-buffer)
  (
    (test3 :accessor test3
     :initform (cl:make-array 0 :element-type 'cl:double-float :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector cl:double-float))

  ))

(cl:export 'SimpleTestArray)


(cl:defun make-SimpleTestArray ()
  (cl:make-instance 'SimpleTestArray))
(cl:export 'make-SimpleTestArray)

(cl:export 'test3)

(cl:defmethod cl:print-object ((object SimpleTestArray) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:format stream "test3: ~s " (test3 object))
  )
  (cl:values))

(cl:defmethod clear ((self SimpleTestArray))
  (cl:setf (cl:slot-value self 'test3)
           (cl:make-array 0 :element-type 'cl:double-float :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self SimpleTestArray))
  cl:t)

(cl:defmethod octet-size ((self SimpleTestArray))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (cl:* 10 (cl:length (test3 self))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb SimpleTestArray) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:let* ((v (test3 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 2425))
    (cl:setf index
     (protocol:write-double-float-carefully buffer index limit (cl:aref v i)))
    ))
  index)

(cl:defmethod merge ((self SimpleTestArray) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((2425)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-double-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'test3))
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestEditingMethods-G1 (protocol-buffer)
  (
    (i2
     :initform 0
     :type base:int32)

    (i3
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'TestEditingMethods-G1)


(cl:defun make-TestEditingMethods-G1 ()
  (cl:make-instance 'TestEditingMethods-G1))
(cl:export 'make-TestEditingMethods-G1)

(cl:defgeneric i2 (proto))
(cl:defmethod i2 ((self TestEditingMethods-G1))
  (cl:slot-value self 'i2))

(cl:defgeneric (cl:setf i2) (new-value proto))
(cl:defmethod (cl:setf i2) (new-value (self TestEditingMethods-G1))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'i2) new-value))

(cl:export 'i2)

(cl:defgeneric i3 (proto))
(cl:defmethod i3 ((self TestEditingMethods-G1))
  (cl:slot-value self 'i3))

(cl:defgeneric (cl:setf i3) (new-value proto))
(cl:defmethod (cl:setf i3) (new-value (self TestEditingMethods-G1))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'i3) new-value))

(cl:export 'i3)

(cl:defgeneric has-i2 (proto))
(cl:defmethod has-i2 ((self TestEditingMethods-G1))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-i2)

(cl:defgeneric has-i3 (proto))
(cl:defmethod has-i3 ((self TestEditingMethods-G1))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-i3)

(cl:defmethod cl:print-object ((object TestEditingMethods-G1) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-i2 object)
      (cl:format stream "i2: ~s " (i2 object)))
    (cl:when (has-i3 object)
      (cl:format stream "i3: ~s " (i3 object)))
  )
  (cl:values))

(cl:defgeneric clear-i2 (proto))
(cl:defmethod clear-i2 ((self TestEditingMethods-G1))
  (cl:setf (cl:slot-value self 'i2) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i2)

(cl:defgeneric clear-i3 (proto))
(cl:defmethod clear-i3 ((self TestEditingMethods-G1))
  (cl:setf (cl:slot-value self 'i3) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i3)

(cl:defmethod clear ((self TestEditingMethods-G1))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'i2) 0)
  (cl:setf (cl:slot-value self 'i3) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TestEditingMethods-G1))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b011) #b011))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestEditingMethods-G1))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (i2 self))))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (i3 self))))
    (cl:+ size 2)))

(cl:defmethod encode ((pb TestEditingMethods-G1) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 11))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (i2 pb))))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (i3 pb))))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 12))
  index)

(cl:defmethod merge ((self TestEditingMethods-G1) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((12)
           (cl:return-from merge index))
          ((16)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'i2) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((24)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'i3) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestEditingMethods-G4 (protocol-buffer)
  (
    (i5
     :initform 0
     :type base:int32)

    (i6
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 2))
  ))

(cl:export 'TestEditingMethods-G4)


(cl:defun make-TestEditingMethods-G4 ()
  (cl:make-instance 'TestEditingMethods-G4))
(cl:export 'make-TestEditingMethods-G4)

(cl:defgeneric i5 (proto))
(cl:defmethod i5 ((self TestEditingMethods-G4))
  (cl:slot-value self 'i5))

(cl:defgeneric (cl:setf i5) (new-value proto))
(cl:defmethod (cl:setf i5) (new-value (self TestEditingMethods-G4))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'i5) new-value))

(cl:export 'i5)

(cl:defgeneric i6 (proto))
(cl:defmethod i6 ((self TestEditingMethods-G4))
  (cl:slot-value self 'i6))

(cl:defgeneric (cl:setf i6) (new-value proto))
(cl:defmethod (cl:setf i6) (new-value (self TestEditingMethods-G4))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'i6) new-value))

(cl:export 'i6)

(cl:defgeneric has-i5 (proto))
(cl:defmethod has-i5 ((self TestEditingMethods-G4))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-i5)

(cl:defgeneric has-i6 (proto))
(cl:defmethod has-i6 ((self TestEditingMethods-G4))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-i6)

(cl:defmethod cl:print-object ((object TestEditingMethods-G4) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-i5 object)
      (cl:format stream "i5: ~s " (i5 object)))
    (cl:when (has-i6 object)
      (cl:format stream "i6: ~s " (i6 object)))
  )
  (cl:values))

(cl:defgeneric clear-i5 (proto))
(cl:defmethod clear-i5 ((self TestEditingMethods-G4))
  (cl:setf (cl:slot-value self 'i5) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i5)

(cl:defgeneric clear-i6 (proto))
(cl:defmethod clear-i6 ((self TestEditingMethods-G4))
  (cl:setf (cl:slot-value self 'i6) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i6)

(cl:defmethod clear ((self TestEditingMethods-G4))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'i5) 0)
  (cl:setf (cl:slot-value self 'i6) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TestEditingMethods-G4))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b001) #b001))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestEditingMethods-G4))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (i5 self))))
    (cl:when (has-i6 self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (i6 self))))))
    (cl:+ size 1)))

(cl:defmethod encode ((pb TestEditingMethods-G4) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 35))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (i5 pb))))
  (cl:when (has-i6 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (i6 pb))))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 36))
  index)

(cl:defmethod merge ((self TestEditingMethods-G4) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((36)
           (cl:return-from merge index))
          ((40)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'i5) value)
              (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((48)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'i6) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestEditingMethods (protocol-buffer)
  (
    (g1 :accessor g1
     :initform (cl:make-array 0 :element-type 'TestEditingMethods-G1 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TestEditingMethods-G1))

    (g4
     :accessor g4
     :initform cl:nil
     :type (cl:or cl:null TestEditingMethods-G4))

    (s7 :accessor s7
     :initform (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:octet-vector))

    (s8
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (s9
     :initform (base:string-to-utf8-octets "")
     :type base:octet-vector)

    (i10 :accessor i10
     :initform (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector base:int32))

    (i11
     :initform 0
     :type base:int32)

    (i12
     :initform 0
     :type base:int32)

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 5))
  ))

(cl:export 'TestEditingMethods)


(cl:defun make-TestEditingMethods ()
  (cl:make-instance 'TestEditingMethods))
(cl:export 'make-TestEditingMethods)

(cl:export 'g1)

(cl:defgeneric g4 (proto))
(cl:defmethod g4 ((self TestEditingMethods))
  (cl:when (cl:null (cl:slot-value self 'g4))
    (cl:setf
      (cl:ldb (cl:byte 1 0)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'g4)
             (make-TestEditingMethods-G4)))
  (cl:slot-value self 'g4))

(cl:defgeneric (cl:setf g4) (new-value proto))
(cl:defmethod (cl:setf g4) (new-value (self TestEditingMethods))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'g4) new-value))

(cl:export 'g4)

(cl:export 's7)

(cl:defgeneric s8 (proto))
(cl:defmethod s8 ((self TestEditingMethods))
  (base:utf8-octets-to-string (cl:slot-value self 's8)))
(cl:defgeneric s8-octets (proto))
(cl:defmethod s8-octets ((self TestEditingMethods))
  (cl:slot-value self 's8))
(cl:export 's8)

(cl:defgeneric (cl:setf s8) (new-value proto))
(cl:defmethod (cl:setf s8) (new-value (self TestEditingMethods))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 's8)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 's8) new-value))))

(cl:export 's8)

(cl:defgeneric s9 (proto))
(cl:defmethod s9 ((self TestEditingMethods))
  (base:utf8-octets-to-string (cl:slot-value self 's9)))
(cl:defgeneric s9-octets (proto))
(cl:defmethod s9-octets ((self TestEditingMethods))
  (cl:slot-value self 's9))
(cl:export 's9)

(cl:defgeneric (cl:setf s9) (new-value proto))
(cl:defmethod (cl:setf s9) (new-value (self TestEditingMethods))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:etypecase new-value
    ((cl:string)
     (cl:setf (cl:slot-value self 's9)
              (base:string-to-utf8-octets new-value)))
    ((base:octet-vector)
     (cl:setf (cl:slot-value self 's9) new-value))))

(cl:export 's9)

(cl:export 'i10)

(cl:defgeneric i11 (proto))
(cl:defmethod i11 ((self TestEditingMethods))
  (cl:slot-value self 'i11))

(cl:defgeneric (cl:setf i11) (new-value proto))
(cl:defmethod (cl:setf i11) (new-value (self TestEditingMethods))
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'i11) new-value))

(cl:export 'i11)

(cl:defgeneric i12 (proto))
(cl:defmethod i12 ((self TestEditingMethods))
  (cl:slot-value self 'i12))

(cl:defgeneric (cl:setf i12) (new-value proto))
(cl:defmethod (cl:setf i12) (new-value (self TestEditingMethods))
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'i12) new-value))

(cl:export 'i12)

(cl:defgeneric has-g4 (proto))
(cl:defmethod has-g4 ((self TestEditingMethods))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-g4)

(cl:defgeneric has-s8 (proto))
(cl:defmethod has-s8 ((self TestEditingMethods))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-s8)

(cl:defgeneric has-s9 (proto))
(cl:defmethod has-s9 ((self TestEditingMethods))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-s9)

(cl:defgeneric has-i11 (proto))
(cl:defmethod has-i11 ((self TestEditingMethods))
  (cl:= (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-i11)

(cl:defgeneric has-i12 (proto))
(cl:defmethod has-i12 ((self TestEditingMethods))
  (cl:= (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-i12)

(cl:defmethod cl:print-object ((object TestEditingMethods) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:format stream "g1: ~s " (g1 object))
    (cl:when (has-g4 object)
      (cl:format stream "g4: ~s " (g4 object)))
    (cl:format stream "s7: ~s " (s7 object))
    (cl:when (has-s8 object)
      (cl:format stream "s8: ~s " (s8 object)))
    (cl:when (has-s9 object)
      (cl:format stream "s9: ~s " (s9 object)))
    (cl:format stream "i10: ~s " (i10 object))
    (cl:when (has-i11 object)
      (cl:format stream "i11: ~s " (i11 object)))
    (cl:when (has-i12 object)
      (cl:format stream "i12: ~s " (i12 object)))
  )
  (cl:values))

(cl:defgeneric clear-g4 (proto))
(cl:defmethod clear-g4 ((self TestEditingMethods))
  (cl:setf (cl:slot-value self 'g4) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-g4)

(cl:defgeneric clear-s8 (proto))
(cl:defmethod clear-s8 ((self TestEditingMethods))
  (cl:setf (cl:slot-value self 's8) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-s8)

(cl:defgeneric clear-s9 (proto))
(cl:defmethod clear-s9 ((self TestEditingMethods))
  (cl:setf (cl:slot-value self 's9) (base:string-to-utf8-octets ""))
  (cl:setf
    (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-s9)

(cl:defgeneric clear-i11 (proto))
(cl:defmethod clear-i11 ((self TestEditingMethods))
  (cl:setf (cl:slot-value self 'i11) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i11)

(cl:defgeneric clear-i12 (proto))
(cl:defmethod clear-i12 ((self TestEditingMethods))
  (cl:setf (cl:slot-value self 'i12) 0)
  (cl:setf
    (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i12)

(cl:defmethod clear ((self TestEditingMethods))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'g1)
           (cl:make-array 0 :element-type 'TestEditingMethods-G1 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'g4) cl:nil)
  (cl:setf (cl:slot-value self 's7)
           (cl:make-array 0 :element-type 'base:octet-vector :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 's8) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 's9) (base:make-octet-vector 0))
  (cl:setf (cl:slot-value self 'i10)
           (cl:make-array 0 :element-type 'base:int32 :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'i11) 0)
  (cl:setf (cl:slot-value self 'i12) 0)
  (cl:values))

(cl:defmethod is-initialized ((self TestEditingMethods))
  (cl:when (cl:not (cl:= (cl:logand (cl:slot-value self '%has-bits%) #b01010) #b01010))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'g1))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 0)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'g4))))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestEditingMethods))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:let ((length (cl:length (g1 self))))
      (cl:incf size (cl:* 2 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (octet-size (cl:aref (g1 self) i)))))
    (cl:when (has-g4 self) (cl:incf size (cl:+ 2 (octet-size (g4 self)))))
    (cl:let ((length (cl:length (s7 self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (cl:length (cl:aref (s7 self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:when (has-s8 self) (cl:incf size (cl:+ 1 (cl:let ((x (cl:length (s8-octets self)))) (cl:+ (varint:length32 x) x)))))
    (cl:incf size (cl:let ((x (cl:length (s9-octets self)))) (cl:+ (varint:length32 x) x)))
    (cl:let ((length (cl:length (i10 self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (varint:length64 (base:int32-to-uint64 (cl:aref (i10 self) i))))))
    (cl:when (has-i11 self) (cl:incf size (cl:+ 1 (varint:length64 (base:int32-to-uint64 (i11 self))))))
    (cl:incf size (varint:length64 (base:int32-to-uint64 (i12 self))))
    (cl:+ size 2)))

(cl:defmethod encode ((pb TestEditingMethods) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:let* ((v (g1 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (encode (cl:aref v i) buffer index limit))
    ))
  (cl:when (has-g4 pb)
    (cl:setf index (encode (g4 pb) buffer index limit))
    )
  (cl:let* ((v (s7 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (cl:aref v i)))
    ))
  (cl:when (has-s8 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (s8-octets pb)))
    )
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
    (cl:setf index
     (protocol:write-octets-carefully buffer index limit (s9-octets pb)))
  (cl:let* ((v (i10 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 80))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (cl:aref v i))))
    ))
  (cl:when (has-i11 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 88))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (i11 pb))))
    )
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 96))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
                                     (base:int32-to-uint64 (i12 pb))))
  index)

(cl:defmethod merge ((self TestEditingMethods) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((11)
            (cl:let ((new (make-TestEditingMethods-G1)))
              (cl:setf index (merge new buffer index limit))
              (cl:vector-push-extend new (cl:slot-value self 'g1)))
          )
          ((35)
            (cl:let ((new-index (merge (g4 self) buffer index limit)))
              (cl:setf index new-index))
          )
          ((58)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 's7))
              (cl:setf index new-index))
          )
          ((66)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 's8) value)
              (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((74)
            (cl:multiple-value-bind (value new-index)
                (protocol:read-octets-carefully buffer index limit)
              (cl:setf (cl:slot-value self 's9) value)
              (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((80)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'i10))
              (cl:setf index new-index))
          )
          ((88)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'i11) value)
              (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          ((96)
            (cl:multiple-value-bind (value new-index)
                (varint:parse-int32-carefully buffer index limit)
              (cl:setf (cl:slot-value self 'i12) value)
              (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
              (cl:setf index new-index))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestRecursive-RepeatedRecursiveGroup (protocol-buffer)
  (
    (r1 :accessor r1
     :initform (cl:make-array 0 :element-type 'TestRecursive :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TestRecursive))

  ))

(cl:export 'TestRecursive-RepeatedRecursiveGroup)


(cl:defun make-TestRecursive-RepeatedRecursiveGroup ()
  (cl:make-instance 'TestRecursive-RepeatedRecursiveGroup))
(cl:export 'make-TestRecursive-RepeatedRecursiveGroup)

(cl:export 'r1)

(cl:defmethod cl:print-object ((object TestRecursive-RepeatedRecursiveGroup) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:format stream "r1: ~s " (r1 object))
  )
  (cl:values))

(cl:defmethod clear ((self TestRecursive-RepeatedRecursiveGroup))
  (cl:setf (cl:slot-value self 'r1)
           (cl:make-array 0 :element-type 'TestRecursive :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self TestRecursive-RepeatedRecursiveGroup))
  (cl:let* ((x (cl:slot-value self 'r1))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self TestRecursive-RepeatedRecursiveGroup))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:let ((length (cl:length (r1 self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (octet-size (cl:aref (r1 self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestRecursive-RepeatedRecursiveGroup) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 11))
  (cl:let* ((v (r1 pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:let ((size (octet-size (cl:aref v i))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (cl:aref v i) buffer index limit)))
    ))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 12))
  index)

(cl:defmethod merge ((self TestRecursive-RepeatedRecursiveGroup) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((12)
           (cl:return-from merge index))
          ((18)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:let ((new (make-TestRecursive)))
                (cl:setf index (merge new buffer new-index (cl:+ new-index length)))
                (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                  (cl:error "buffer overflow"))
                (cl:vector-push-extend new (cl:slot-value self 'r1))))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestRecursive-OptionalRecursiveGroup (protocol-buffer)
  (
    (r2
     :accessor r2
     :initform cl:nil
     :type (cl:or cl:null TestRecursive))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 1))
  ))

(cl:export 'TestRecursive-OptionalRecursiveGroup)


(cl:defun make-TestRecursive-OptionalRecursiveGroup ()
  (cl:make-instance 'TestRecursive-OptionalRecursiveGroup))
(cl:export 'make-TestRecursive-OptionalRecursiveGroup)

(cl:defgeneric r2 (proto))
(cl:defmethod r2 ((self TestRecursive-OptionalRecursiveGroup))
  (cl:when (cl:null (cl:slot-value self 'r2))
    (cl:setf
      (cl:ldb (cl:byte 1 0)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'r2)
             (make-TestRecursive)))
  (cl:slot-value self 'r2))

(cl:defgeneric (cl:setf r2) (new-value proto))
(cl:defmethod (cl:setf r2) (new-value (self TestRecursive-OptionalRecursiveGroup))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'r2) new-value))

(cl:export 'r2)

(cl:defgeneric has-r2 (proto))
(cl:defmethod has-r2 ((self TestRecursive-OptionalRecursiveGroup))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-r2)

(cl:defmethod cl:print-object ((object TestRecursive-OptionalRecursiveGroup) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-r2 object)
      (cl:format stream "r2: ~s " (r2 object)))
  )
  (cl:values))

(cl:defgeneric clear-r2 (proto))
(cl:defmethod clear-r2 ((self TestRecursive-OptionalRecursiveGroup))
  (cl:setf (cl:slot-value self 'r2) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-r2)

(cl:defmethod clear ((self TestRecursive-OptionalRecursiveGroup))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'r2) cl:nil)
  (cl:values))

(cl:defmethod is-initialized ((self TestRecursive-OptionalRecursiveGroup))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 0)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'r2))))
    (cl:return-from is-initialized cl:nil))
  cl:t)

(cl:defmethod octet-size ((self TestRecursive-OptionalRecursiveGroup))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-r2 self) (cl:incf size (cl:+ 1 (cl:let ((x (octet-size (r2 self)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestRecursive-OptionalRecursiveGroup) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 27))
  (cl:when (has-r2 pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:let ((size (octet-size (r2 pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (r2 pb) buffer index limit)))
    )
  (cl:setf index (varint:encode-uint32-carefully buffer index limit 28))
  index)

(cl:defmethod merge ((self TestRecursive-OptionalRecursiveGroup) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((28)
           (cl:return-from merge index))
          ((34)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (r2 self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

(cl:defclass TestRecursive (protocol-buffer)
  (
    (repeatedrecursivegroup
     :accessor repeatedrecursivegroup
     :initform cl:nil
     :type (cl:or cl:null TestRecursive-RepeatedRecursiveGroup))

    (optionalrecursivegroup
     :accessor optionalrecursivegroup
     :initform cl:nil
     :type (cl:or cl:null TestRecursive-OptionalRecursiveGroup))

    (optional_recursive
     :accessor optional_recursive
     :initform cl:nil
     :type (cl:or cl:null TestRecursive))

    (repeated_recursive :accessor repeated_recursive
     :initform (cl:make-array 0 :element-type 'TestRecursive :fill-pointer 0 :adjustable cl:t)
     :type (cl:vector TestRecursive))

    (%has-bits% :accessor %has-bits%
                :initform 0
                :type (cl:unsigned-byte 3))
  ))

(cl:export 'TestRecursive)


(cl:defun make-TestRecursive ()
  (cl:make-instance 'TestRecursive))
(cl:export 'make-TestRecursive)

(cl:defgeneric repeatedrecursivegroup (proto))
(cl:defmethod repeatedrecursivegroup ((self TestRecursive))
  (cl:when (cl:null (cl:slot-value self 'repeatedrecursivegroup))
    (cl:setf
      (cl:ldb (cl:byte 1 0)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'repeatedrecursivegroup)
             (make-TestRecursive-RepeatedRecursiveGroup)))
  (cl:slot-value self 'repeatedrecursivegroup))

(cl:defgeneric (cl:setf repeatedrecursivegroup) (new-value proto))
(cl:defmethod (cl:setf repeatedrecursivegroup) (new-value (self TestRecursive))
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'repeatedrecursivegroup) new-value))

(cl:export 'repeatedrecursivegroup)

(cl:defgeneric optionalrecursivegroup (proto))
(cl:defmethod optionalrecursivegroup ((self TestRecursive))
  (cl:when (cl:null (cl:slot-value self 'optionalrecursivegroup))
    (cl:setf
      (cl:ldb (cl:byte 1 1)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'optionalrecursivegroup)
             (make-TestRecursive-OptionalRecursiveGroup)))
  (cl:slot-value self 'optionalrecursivegroup))

(cl:defgeneric (cl:setf optionalrecursivegroup) (new-value proto))
(cl:defmethod (cl:setf optionalrecursivegroup) (new-value (self TestRecursive))
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'optionalrecursivegroup) new-value))

(cl:export 'optionalrecursivegroup)

(cl:defgeneric optional_recursive (proto))
(cl:defmethod optional_recursive ((self TestRecursive))
  (cl:when (cl:null (cl:slot-value self 'optional_recursive))
    (cl:setf
      (cl:ldb (cl:byte 1 2)
              (cl:slot-value self '%has-bits%))
      1)
    (cl:setf (cl:slot-value self 'optional_recursive)
             (make-TestRecursive)))
  (cl:slot-value self 'optional_recursive))

(cl:defgeneric (cl:setf optional_recursive) (new-value proto))
(cl:defmethod (cl:setf optional_recursive) (new-value (self TestRecursive))
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
  (cl:setf (cl:slot-value self 'optional_recursive) new-value))

(cl:export 'optional_recursive)

(cl:export 'repeated_recursive)

(cl:defgeneric has-repeatedrecursivegroup (proto))
(cl:defmethod has-repeatedrecursivegroup ((self TestRecursive))
  (cl:= (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-repeatedrecursivegroup)

(cl:defgeneric has-optionalrecursivegroup (proto))
(cl:defmethod has-optionalrecursivegroup ((self TestRecursive))
  (cl:= (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-optionalrecursivegroup)

(cl:defgeneric has-optional_recursive (proto))
(cl:defmethod has-optional_recursive ((self TestRecursive))
  (cl:= (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%))
                1))
(cl:export 'has-optional_recursive)

(cl:defmethod cl:print-object ((object TestRecursive) stream)
  (cl:print-unreadable-object (object stream :type cl:t :identity cl:t)
    (cl:when (has-repeatedrecursivegroup object)
      (cl:format stream "repeatedrecursivegroup: ~s " (repeatedrecursivegroup object)))
    (cl:when (has-optionalrecursivegroup object)
      (cl:format stream "optionalrecursivegroup: ~s " (optionalrecursivegroup object)))
    (cl:when (has-optional_recursive object)
      (cl:format stream "optional_recursive: ~s " (optional_recursive object)))
    (cl:format stream "repeated_recursive: ~s " (repeated_recursive object))
  )
  (cl:values))

(cl:defgeneric clear-repeatedrecursivegroup (proto))
(cl:defmethod clear-repeatedrecursivegroup ((self TestRecursive))
  (cl:setf (cl:slot-value self 'repeatedrecursivegroup) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-repeatedrecursivegroup)

(cl:defgeneric clear-optionalrecursivegroup (proto))
(cl:defmethod clear-optionalrecursivegroup ((self TestRecursive))
  (cl:setf (cl:slot-value self 'optionalrecursivegroup) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-optionalrecursivegroup)

(cl:defgeneric clear-optional_recursive (proto))
(cl:defmethod clear-optional_recursive ((self TestRecursive))
  (cl:setf (cl:slot-value self 'optional_recursive) cl:nil)
  (cl:setf
    (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-optional_recursive)

(cl:defmethod clear ((self TestRecursive))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:setf (cl:slot-value self 'repeatedrecursivegroup) cl:nil)
  (cl:setf (cl:slot-value self 'optionalrecursivegroup) cl:nil)
  (cl:setf (cl:slot-value self 'optional_recursive) cl:nil)
  (cl:setf (cl:slot-value self 'repeated_recursive)
           (cl:make-array 0 :element-type 'TestRecursive :fill-pointer 0 :adjustable cl:t))
  (cl:values))

(cl:defmethod is-initialized ((self TestRecursive))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 0)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'repeatedrecursivegroup))))
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 1)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'optionalrecursivegroup))))
    (cl:return-from is-initialized cl:nil))
  (cl:when (cl:and
            (cl:= (cl:ldb (cl:byte 1 2)
                          (cl:slot-value self '%has-bits%))
                  1)
            (cl:not (is-initialized (cl:slot-value self 'optional_recursive))))
    (cl:return-from is-initialized cl:nil))
  (cl:let* ((x (cl:slot-value self 'repeated_recursive))
         (length (cl:length x)))
    (cl:loop for i from 0 below length
          do (cl:when (cl:not (is-initialized (cl:aref x i)))
               (cl:return-from is-initialized cl:nil))))
  cl:t)

(cl:defmethod octet-size ((self TestRecursive))
  (cl:assert (is-initialized self))
  (cl:let ((size 0))
    (cl:when (has-repeatedrecursivegroup self) (cl:incf size (cl:+ 2 (octet-size (repeatedrecursivegroup self)))))
    (cl:when (has-optionalrecursivegroup self) (cl:incf size (cl:+ 2 (octet-size (optionalrecursivegroup self)))))
    (cl:when (has-optional_recursive self) (cl:incf size (cl:+ 1 (cl:let ((x (octet-size (optional_recursive self)))) (cl:+ (varint:length32 x) x)))))
    (cl:let ((length (cl:length (repeated_recursive self))))
      (cl:incf size (cl:* 1 length))
      (cl:loop for i from 0 below length
            do (cl:incf size (cl:let ((x (octet-size (cl:aref (repeated_recursive self) i)))) (cl:+ (varint:length32 x) x)))))
    (cl:+ size 0)))

(cl:defmethod encode ((pb TestRecursive) buffer index limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index index limit)
           (cl:ignorable buffer limit))
  (cl:when (has-repeatedrecursivegroup pb)
    (cl:setf index (encode (repeatedrecursivegroup pb) buffer index limit))
    )
  (cl:when (has-optionalrecursivegroup pb)
    (cl:setf index (encode (optionalrecursivegroup pb) buffer index limit))
    )
  (cl:when (has-optional_recursive pb)
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:let ((size (octet-size (optional_recursive pb))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (optional_recursive pb) buffer index limit)))
    )
  (cl:let* ((v (repeated_recursive pb))
         (length (cl:length v)))
    (cl:loop for i from 0 below length
          do
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
    (cl:let ((size (octet-size (cl:aref v i))))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit size))
      (cl:setf index (encode (cl:aref v i) buffer index limit)))
    ))
  index)

(cl:defmethod merge ((self TestRecursive) buffer start limit)
  (cl:declare (cl:type base:octet-vector buffer)
           (cl:type base:octet-vector-index start limit))
    (cl:do ((index start index))
        ((cl:>= index limit) index)
      (cl:declare (cl:type base:octet-vector-index index))
      (cl:multiple-value-bind (tag new-index)
          (varint:parse-uint32-carefully buffer index limit)
        (cl:setf index new-index)
        (cl:case tag
          ((11)
            (cl:let ((new-index (merge (repeatedrecursivegroup self) buffer index limit)))
              (cl:setf index new-index))
          )
          ((27)
            (cl:let ((new-index (merge (optionalrecursivegroup self) buffer index limit)))
              (cl:setf index new-index))
          )
          ((42)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:setf index (merge (optional_recursive self) buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))
          )
          ((50)
            (cl:multiple-value-bind (length new-index)
                (varint:parse-uint31-carefully buffer index limit)
              (cl:when (cl:> (cl:+ new-index length) limit)
                (cl:error "buffer overflow"))
              (cl:let ((new (make-TestRecursive)))
                (cl:setf index (merge new buffer new-index (cl:+ new-index length)))
                (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                  (cl:error "buffer overflow"))
                (cl:vector-push-extend new (cl:slot-value self 'repeated_recursive))))
          )
          (cl:t
            ;; Tag 0 is special.  It is used to indicate an error,
            ;; so we return as error code when we see it.
            (cl:when (cl:zerop tag)
              (cl:return-from merge cl:nil)))
          ))))

